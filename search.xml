<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[基础加固-建造者模式]]></title>
    <url>%2F2019%2F07%2F09%2F%E5%9F%BA%E7%A1%80%E5%8A%A0%E5%9B%BA-%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[&ensp;&ensp;&ensp;上篇我们复习了工厂模式，这节我们来看一下创建型设计模式的另一种模式–建造者模式。 一.定义&ensp;&ensp;&ensp;建造者模式是指将一个复杂对象的构建和它的表示分离，使同样的构建过程可以构建不同的表示。用户只需要指定需要建造的类型就可以得到它们，建造过程以及细节并不需要知道。适用于那些创建流程固定，但顺序不一定固定的对象。如果一个对象有非常复杂的内部结构，即有很多属性，我们想把这种复杂对象的创建和使用进行分离，我们可以使用建造者模式。这样看定义难免抽象，接下来我们一起编写代码来加深对工厂模式的理解。 二、标准版1.代码实现&ensp;&ensp;&ensp;首先我们有一个类Game，有名称、简介、制作团队、宣传视频、社区几个属性。代码如下：Game.java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public class Game &#123; private String name; private String introduce; private String team; private String video; private String community; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getIntroduce() &#123; return introduce; &#125; public void setIntroduce(String introduce) &#123; this.introduce = introduce; &#125; public String getTeam() &#123; return team; &#125; public void setTeam(String team) &#123; this.team = team; &#125; public String getVideo() &#123; return video; &#125; public void setVideo(String video) &#123; this.video = video; &#125; public String getCommunity() &#123; return community; &#125; public void setCommunity(String community) &#123; this.community = community; &#125; @Override public String toString() &#123; return "Game&#123;" + "name='" + name + '\'' + ", introduce='" + introduce + '\'' + ", team='" + team + '\'' + ", video='" + video + '\'' + ", community='" + community + '\'' + '&#125;'; &#125;&#125; 我们创建一个抽象类GameBuilder，其中定义了创建各个属性的方法和生成Game对象的方法，代码如下：GameBuilder.java12345678910111213public abstract class GameBuilder &#123; public abstract void buildName(String name); public abstract void buildIntroduce(String introduce); public abstract void buildTeam(String team); public abstract void buildVideo(String video); public abstract void buildCommunity(String community); public abstract Game makeGame();&#125; 接下来我们要创建具体的builder实现，比如我们要创建一个动作游戏的建造者ActionGameBuilder，我们只需要继承上面的抽象builder，重写里面的方法即可，代码如下：ActionGameBuilder.java123456789101112131415161718192021222324252627282930313233public class ActionGameBuilder extends GameBuilder &#123; Game game = new Game(); @Override public void buildName(String name) &#123; game.setName(name); &#125; @Override public void buildIntroduce(String introduce) &#123; game.setIntroduce(introduce); &#125; @Override public void buildTeam(String team) &#123; game.setTeam(team); &#125; @Override public void buildVideo(String video) &#123; game.setVideo(video); &#125; @Override public void buildCommunity(String community) &#123; game.setCommunity(community); &#125; @Override public Game makeGame() &#123; return game; &#125;&#125; 其实现在我们已经可以使用我们创建的builder进行创建游戏了，不过这里可以定义一个管理角色的对象，对builder进行管理，用它来进行管理对象的创建，这里我们定义一个游戏经理类GameManager。GameManager.java1234567891011121314151617public class GameManager &#123; private GameBuilder gameBuilder; public void setGameBuilder(GameBuilder gameBuilder) &#123; this.gameBuilder = gameBuilder; &#125; public Game makeGame(String name, String introduce, String team, String video, String community) &#123; gameBuilder.buildName(name); gameBuilder.buildIntroduce(introduce); gameBuilder.buildTeam(team); gameBuilder.buildVideo(video); gameBuilder.buildCommunity(community); return gameBuilder.makeGame(); &#125;&#125;写到这里我们已经完成了一个标准的建造者模式代码，写一个测试类来测试一下。Test.java123456789101112131415public class Test &#123; public static void main(String[] args) &#123; GameBuilder gameBuilder = new ActionGameBuilder(); GameManager manager = new GameManager(); manager.setGameBuilder(gameBuilder); Game game = manager.makeGame("游戏名称", "这是一个很好玩的动作游戏", "制作团队", "游戏宣传视频", "游戏社区"); System.out.println(game); &#125;&#125;控制台可以看到创建的游戏信息。123Game&#123;name=&apos;游戏名称&apos;, introduce=&apos;这是一个很好玩的动作游戏&apos;, team=&apos;制作团队&apos;, video=&apos;游戏宣传视频&apos;, community=&apos;游戏社区&apos;&#125;Process finished with exit code 0 2.UML&ensp;&ensp;&ensp;我们可以看到标准的建造者模式的UML类图。我们测试时通过游戏经理和动作游戏建造者创建了含有较多属性的游戏类，并不关心创建的过程和顺序，有很好的封装性，使创建和使用分离，并且有很好的扩展性，建造类之间独立，在一定程度上解耦。 三、演进版1.代码实现&ensp;&ensp;&ensp;更多时候我们需要一种可以链式调用的形式进行建造我们的对象，实现其实也很简单，我们可以创建一个静态内部类作为对象的builder，具体代码如下：Game.java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364public class Game &#123; private String name; private String introduce; private String team; private String video; private String community; public Game(GameBuilder gameBuilder) &#123; this.name = gameBuilder.name; this.introduce = gameBuilder.introduce; this.team = gameBuilder.team; this.video = gameBuilder.video; this.community = gameBuilder.community; &#125; @Override public String toString() &#123; return "Game&#123;" + "name='" + name + '\'' + ", introduce='" + introduce + '\'' + ", team='" + team + '\'' + ", video='" + video + '\'' + ", community='" + community + '\'' + '&#125;'; &#125; public static class GameBuilder &#123; private String name; private String introduce; private String team; private String video; private String community; public GameBuilder buildName(String name) &#123; this.name = name; return this; &#125; public GameBuilder buildIntroduce(String introduce) &#123; this.introduce = introduce; return this; &#125; public GameBuilder buildTeam(String team) &#123; this.team = team; return this; &#125; public GameBuilder buildVideo(String video) &#123; this.video = video; return this; &#125; public GameBuilder buildCommunity(String community) &#123; this.community = community; return this; &#125; public Game build() &#123; return new Game(this); &#125; &#125;&#125;&ensp;&ensp;&ensp;跟标准版本不同的是，在builder中的buildXxx方法返回的是builder本身，这样我们就可以使用链式调用的方式进行创建，最后调用build方法返回我们的实体类。写一个测试类测试一下。Test.java1234567891011public class Test &#123; public static void main(String[] args) &#123; Game game = new Game.GameBuilder().buildName("游戏名称") .buildIntroduce("这是一个很好玩的游戏") .buildTeam("制作团队") .buildVideo("介绍视频") .buildCommunity("游戏社区") .build(); System.out.println(game); &#125;&#125;执行程序，可以看到我们创建的game的信息。123Game&#123;name=&apos;游戏名称&apos;, introduce=&apos;这是一个很好玩的游戏&apos;, team=&apos;制作团队&apos;, video=&apos;介绍视频&apos;, community=&apos;游戏社区&apos;&#125;Process finished with exit code 0 2.UML&ensp;&ensp;&ensp;演进版本的UML类图更加简单，可以很清楚地看到，对于应用方，只需要使用对象的builder进行链式调用，最后调用build方法返回所需的对象实例即可。 四、总结&ensp;&ensp;&ensp;以上介绍了两个版本的建造者模式的实现，总体来说都是比较简单，容易理解的。在日常应用中，第二种是比较常用的，各种开源框架也都广泛使用，比如Guava中CacheBuilder，都是通过第二种链式调用的方式创建对象，使用方便。对于以后的扩展维护也比较方便。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>基础</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基础加固-工厂模式]]></title>
    <url>%2F2019%2F06%2F27%2F%E5%9F%BA%E7%A1%80%E5%8A%A0%E5%9B%BA-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[&ensp;&ensp;&ensp;随着工作年限的增加，对工作中的代码结构和质量的追求也在增加。之前看书学习过的设计模式，当时也就是看看，看过或许有的忘记，或许不会使用。入职新公司以来，看团队高级工程师的代码，为了实现一个需求，可以使用合适的设计模式去规范代码，使代码的可读性和可扩展性都大大提升，我意识到是时候巩固一下基础，系统学习一下设计模式了。从这边文章开始，我将从创建型模式中的工厂模式开始复习，实现简单的demo，对比各个模式的UML类图，希望提升自己的编码能力，同时也便于阅读各种开源框架的源码。闲话少许，我们开始吧~ 一、简单工厂模式1.问题引入&ensp;&ensp;&ensp;首先来看一个场景，我有一个抽象类Game，标识这个类为一个游戏，游戏可以有很多种，比如“马里奥”、“塞尔达”等等。创建一个具体的游戏，一种最简单的方式就是创建一个具体游戏类继承Game抽象类，然后重写里面的建造方法。代码如下：Game.java123public abstract class Game &#123; public abstract void produce();&#125; Mario游戏MarioGame.java123456public class MarioGame extends Game&#123; @Override public void produce() &#123; System.out.println("Mario game produced!"); &#125;&#125; Zelda游戏ZeldaGame.java123456public class ZeldaGame extends Game &#123; @Override public void produce() &#123; System.out.println("Zelda game produced!"); &#125;&#125;这样我们在需要创建某种游戏的时候，直接new对应的具体游戏类,调用其中的建造方法即可。ZeldaGame.java123456public class Test &#123; public static void main(String[] args) &#123; Game game = new MarioGame(); game.produce(); &#125;&#125;可以看到控制台中打印的结果，创建了Mario游戏123Mario game produced!Process finished with exit code 0&ensp;&ensp;&ensp;看到这里，大家肯定已经发现了这种写法的弊端。每次需要直接new出来想要的具体游戏类，我们如果能使用一个工具去创建我们想要的具体游戏类，不需要关心创建的过程，那岂不是很爽吗？这时候简单工厂模式就登场了。 2.代码实现&ensp;&ensp;&ensp;和上面一样，还是有我们的抽象游戏Game类，不同的游戏去继承Game类，实现自己的produce方法。不同的是，这次我们创建一个简单工厂类GameFactory，根据参数通过这个工厂去创建我们需要的具体游戏类。具体代码如下：GameFactory.java1234567891011public class GameFactory &#123; public Game getGame(String type)&#123; if ("mario".equalsIgnoreCase(type))&#123; return new MarioGame(); &#125;else if ("zelda".equalsIgnoreCase(type))&#123; return new ZeldaGame(); &#125;else &#123; return null; &#125; &#125;&#125;这样，我们在使用工厂类创建具体游戏类的时候就不用直接new出来具体的游戏，直接使用工厂类就可以了。GameFactory.java12345678910public class Test &#123; public static void main(String[] args) &#123; GameFactory gameFactory = new GameFactory(); Game game = gameFactory.getGame("zelda"); if (game == null)&#123; return; &#125; game.produce(); &#125;&#125;结果如下，我们成功创建了zelda游戏123Zelda game produced!Process finished with exit code 0 3.UML我们先看一下未引入简单工厂时候的UML类图。&ensp;&ensp;&ensp;可以看到我们创建Mario和Zelda两个游戏，都分别通过具体的类进行创建，以后如果要创建更多的游戏，那时的UML大家应该可以想象，从应用方向不同的具体游戏类都会有create联系，整个关系就非常杂乱。我们使用了简单工厂模式之后的UML是什么样的呢？ &ensp;&ensp;&ensp;这样应用方使用简单工厂创建不同的游戏时，只需要告诉工厂我需要什么游戏即可，就不必关心我应该具体new什么游戏了。&ensp;&ensp;&ensp;当然这里实现的简单工厂是最简单的形式，其实完全可以在工厂类中使用java反射创建不同的游戏，在应用方使用的时候，传入对应的Class即可 二、工厂方法模式1.问题引入&ensp;&ensp;&ensp;通过上面简单工厂模式，我们已经可以通过工厂来创建具体的对象。但是这时候我需要增加一个新的“精灵宝可梦”的游戏，我们怎么操作呢？也很简单，新建一个Pokemon游戏的类继承Game，实现自己的produce方法，在工厂类中修改逻辑，使工厂可以创建新的游戏。你可能会说，这样也很好啊，创建新游戏的时候我只需要去改工厂里的逻辑就好了，但是当类越来越多，逻辑越来越复杂，你的工厂类就会变得特别庞大，每次创建新的游戏都要修改这个工厂类，是不符合软件设计中的开闭原则的。这时候，如果按不同游戏的类型把工厂分为不同的工厂，创建的时候只需要使用对应的工厂生产我们需要的游戏就好了。 2.代码实现&ensp;&ensp;&ensp;首先我们新创建“精灵宝可梦”游戏类，同样让它继承Game。PokemonGame.java123456public class PokemonGame extends Game &#123; @Override public void produce() &#123; System.out.println("Pokemon game produced!"); &#125;&#125;刚刚说到，要按不同游戏的类型创建不同的工厂，这里我们首先把工厂抽象出来，建一个抽象工厂类GameFactory.java123public abstract class GameFactory &#123; public abstract Game getGame();&#125;之后，通过继承这个抽象工厂类，创建“马里奥”、“塞尔达”、“精灵宝可梦”的工厂MarioGameFactory.java123456public class MarioGameFactory extends GameFactory &#123; @Override public Game getGame() &#123; return new MarioGame(); &#125;&#125;ZeldaGameFactory.java123456public class ZeldaGameFactory extends GameFactory &#123; @Override public Game getGame() &#123; return new ZeldaGame(); &#125;&#125;PokemonGameFactory.java123456public class PokemonGameFactory extends GameFactory &#123; @Override public Game getGame() &#123; return new PokemonGame(); &#125;&#125;这些不同的工厂创建后，我们就可以使用各自的工厂来生产各自的游戏了，这里以生产Pokemon游戏为例Test.java1234567public class Test &#123; public static void main(String[] args) &#123; GameFactory gameFactory = new PokemonGameFactory(); Game game = gameFactory.getGame(); game.produce(); &#125;&#125;执行代码，控制台输出如下：123Pokemon game produced!Process finished with exit code 0我们已经成功将简单工厂升级成了工厂方法模式，提高了代码的可复用性。 3.UML这时候的UML类图如下: 三、抽象工厂模式1.问题引入&ensp;&ensp;&ensp;假如每个游戏都有一个游戏社区，比如Mario有游戏还有游戏社区，Pokemon也有游戏和游戏社区，这里Mario的游戏和社区属于同一个产品族，Pokemon的游戏和社区也属于同一个产品族；而Mario的游戏社区和Pokemon的游戏社区属于同一产品等级，Mario游戏和Pokemon游戏属于同一产品等级。有类似于这种关系的场景，我们使用一种怎样的模式呢？ 2.代码实现&ensp;&ensp;&ensp;首先我们创建一个接口，抽象出来一个工厂GameFactory，这个抽象工厂定义了可以获取游戏和游戏社区的方法。GameFactory.java12345public interface GameFactory &#123; Game getGame(); Community getCommunity();&#125;其中Game和Community是抽象类，具体的游戏和社区需要继承这两个抽象类自己去实现。Game.java123public abstract class Game &#123; public abstract void produce();&#125;Community.java123public abstract class Community &#123; public abstract void produce();&#125;MarioGame.java123456public class MarioGame extends Game &#123; @Override public void produce() &#123; System.out.println("Mario game produced!"); &#125;&#125;MarioCommunity.java123456public class MarioCommunity extends Community &#123; @Override public void produce() &#123; System.out.println("Mario community produced."); &#125;&#125;之后定义不同的具体工厂，实现GameFactory接口，实现接口中的获取游戏和游戏社区的方法。这里的游戏和社区属于同一产品族，使用具体的工厂可以获得同一产品族的对象。Mario产品族的工厂MarioFactory.java1234567891011public class MarioFactory implements GameFactory &#123; @Override public Game getGame() &#123; return new MarioGame(); &#125; @Override public Community getCommunity() &#123; return new MarioCommunity(); &#125;&#125;Pokemon产品族的工厂PokemonFactory.java1234567891011public class PokemonFactory implements GameFactory &#123; @Override public Game getGame() &#123; return new PokemonGame(); &#125; @Override public Community getCommunity() &#123; return new PokemonCommunity(); &#125;&#125;我们写一个测试类测试一下。Test.java123456789101112public class Test &#123; public static void main(String[] args) &#123; //创建抽象工厂，指定是Mario工厂 GameFactory gameFactory = new MarioFactory(); //调用抽象工厂的方法获取游戏和游戏社区 Game game = gameFactory.getGame(); Community community = gameFactory.getCommunity(); //会根据具体工厂的不同获得不同的游戏和游戏社区，这里是Mario产品族 game.produce(); community.produce(); &#125;&#125; 3.UML我们来看一下现在的UML类图。&ensp;&ensp;&ensp;关系很清晰，大家都可以理解。现在想一个问题，如果我们的业务场景需要经常增加产品族内的产品，那么我们总是需要增加抽象工厂里的方法，进而修改抽象工厂的实现，这么一来就不符合软件设计的开闭原则了；如果我们的业务场景需要经常增加产品等级，这时候我们仅需要添加相应的产品工厂和产品类即可。 &ensp;&ensp;&ensp;以上介绍了三种工厂相关的模式，不能说哪种模式更优于哪种，只能根据具体的业务场景，选择合适的模式。没有最好的设计模式，只有最适合的设计模式。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>基础</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记一次大批量物理删除数据]]></title>
    <url>%2F2019%2F04%2F29%2F%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%A4%A7%E6%89%B9%E9%87%8F%E7%89%A9%E7%90%86%E5%88%A0%E9%99%A4%E6%95%B0%E6%8D%AE%2F</url>
    <content type="text"><![CDATA[&ensp;&ensp;&ensp;接上次闹钟项目更改字符集之后，这几天又需要对线上数据做处理。背景是，同步闹钟的时候会把用户之前删除过的闹钟都同步下来，而删除的闹钟在客户端没有任何显示，也没有任何恢复的操作，对于用户来说其实是完全没有用的数据。当用户的无用历史闹钟增多到一定数量，同步的时候，客户端上报的数据body就特别大，已经超过了Nginx配置的request最大限制，这样就导致了部分老用户无法同步的情况。解决思路其实很简单，将客户端的上报策略修改成分批上传，服务端分批的返回，最后的结果客户端在本地做聚合，显示给用户。但是这需要客户端和服务端共同修改，客户端还要发版审核，现在需要一种比较快速的方式，让用户在尽可能短的时间内可以进行同步。最后决定将数据库中2018年以前用户无用的闹钟进行删除，找到dba同学商量要删除数据，但是很不幸，dba同学告知我们目前他们没有成熟的工具操作，让我们自己写程序删除，他们可以负责备份数据。看来只能靠自己了，接下来就看一下从分析到实现整个删除任务的具体过程。 一、思路分析&ensp;&ensp;&ensp;需要进行删除的这张表是一个很宽的数据量很大的表，当前共有七千多万条数据，经过筛选查询，发现2018年之前且状态为无效的闹钟数量达到了五千多万，也就是说现在需求是要物理删除这五千多万条数据。需求明确了，下面就要考虑几个问题。 要删除的五千多万条数据如何定位？ 怎样高效地删除这么大量的数据同时保证负载正常？ 怎样保证集群环境下，删除任务只执行一次？ 我们分别看一下解决这些问题的思路。 1.定位目标数据&ensp;&ensp;&ensp;表中主要字段包括user_id,status,init_time,分别表示闹钟所属的用户id、闹钟状态、闹钟初始化时间。删除的大体思路是通过in user_id字段来delete，那么如何找到要in哪些user_id呢？从上面的分析可以知道，这张表拥有很大的数据量，想要一次delete是不可能的事情，需要进行分批删除，每次in一部分user_id。那么每次的user_id如何获取呢？可以通过分页排序的group by语句得到分批的user_id。 1select user_id from clocks order by user_id group by user_id limit 0,500; &ensp;&ensp;&ensp;上面的分页查询看上去没什么问题，但是随着翻页次数增大，效率也越来越慢，假设我们翻到了2000页，这个语句查询的2000之前的数据都是无用的，效率特别低下。由数据量分析可知，这张表里通过user_id分组，可以得到200W+数据，如果我们每次分页查询500条，计算可得 最后我们需要将 200W / 500 作为limit的起点，这样的查询是灾难性的。但是通过下面的sql修改，可以大大提高分页的查询效率。 1234select user_id from clocks where user_id &gt; 0 order by user_id group by user_id limit 500;select user_id from clocks where user_id &gt; 500 order by user_id group by user_id limit 500;select user_id from clocks where user_id &gt; 1000 order by user_id group by user_id limit 500;... &ensp;&ensp;&ensp;通过where过滤当前页之前的数据，可以大大提高查询效率。只需要每次记下当次分页结果中最大的user_id，下次分页将此user_id作为分页起始条件进行过滤即可。因为我们使用order by进行排序，查询结果都是有序的，可以将每次的user_id结果放进一个LinkedList中，每次使用的时候peekLast()就能得到当前分组的最大user_id。定位目标数据的思路大体就是这样，思路清晰后代码实现也是很容易的。 ClockDeleteUser.java12345678910111213141516@Datapublic class ClockDeleteUser &#123; // 下一次分页的起始user_id private long nextFirstUserId; private LinkedList&lt;Long&gt; userIds; private int perLimit; public ClockDeleteUser(long nextFirstUserId,int perLimit)&#123; this.nextFirstUserId = nextFirstUserId; this.perLimit = perLimit; &#125;&#125; ClockDeleteService.java123456789101112131415161718192021222324252627282930313233343536@Servicepublic class ClockDeleteService &#123; private final static int DELETE_USER_PER_LIMIT = 500; @Autowired private SyncDao syncDao; /** * 获取删除语句中in的userId的信息集合 * @return */ public List&lt;List&lt;Long&gt;&gt; getDeleteUser()&#123; List&lt;List&lt;Long&gt;&gt; result = new ArrayList&lt;&gt;(); long nextFirstUserId = 0; ClockDeleteUser clockDeleteUser = new ClockDeleteUser(nextFirstUserId,DELETE_USER_PER_LIMIT); LinkedList&lt;Long&gt; userIds = syncDao.getClockDeleteUserIds(clockDeleteUser); while (CollectionUtils.isNotEmpty(userIds))&#123; result.add(userIds); clockDeleteUser.setNextFirstUserId(userIds.peekLast()); userIds = syncDao.getClockDeleteUserIds(clockDeleteUser); &#125; return result; &#125; /** * 按照userId集合删除无用的闹钟 * @param userIds * @return */ public boolean deleteUnusedClock(List&lt;Long&gt; userIds)&#123; // 分批删除无用闹钟 return syncDao.deleteUnusedClocksByUserInitTime(userIds); &#125;&#125; 2.多线程删除&ensp;&ensp;&ensp;找到了每次分批的user_id条件，接下来就可以进行删除操作了。这么庞大的数据量，每次串行执行delete where，明显效率很低，估计删除完这些数据也要进行几个小时吧。这时我们很容易地想到了使用多个线程同时进行delete操作。因为user_id字段是这张表的索引，所以delete的时候走索引，并不会锁住整个表，所以我们可以使用多个线程同时进行删除。但是由于数据量大，分组要达4000+，我们要使用多少个线程同时工作呢？这里我们通过 Runtime.getRuntime().availableProcessors() 获取当前可用处理器数量，用来创建线程池。&ensp;&ensp;&ensp;我们使用 Executors.newFixedThreadPool() 创建固定线程数的线程池，传入的参数就是上面获取的处理器的数量。当工作线程到达了处理器数量，新进来的任务便会进入阻塞队列等待，待工作线程中有任务完成，阻塞队列中的任务再执行。线程池的工作原理，大家应该都已经很熟悉了，在此就不多说了。多线程执行当然能提高效率，但是我们能将这4000+的任务一下子提交给线程池来执行吗？这样的话cpu会有突然增长，这里我们可以使用限流策略，控制任务进入线程池的速度。Google Guava中提供了一个很好用的限流工具，它就是 RateLimiter，一个基于令牌桶算法实现的限流器，想必大家也都知道。使用RateLimiter可以很方便地实现限流。&ensp;&ensp;&ensp;通过以上的思考，多线程删除也可以很简单地实现，在文章的后面我会给出实现代码。 3.集群中单点执行任务&ensp;&ensp;&ensp;应用部署在集群中，但是我们需求的任务只需要一台机器执行即可。我们如何来保证集群中只有一台机器执行这个删除任务呢？&ensp;&ensp;&ensp;我们可以使用Redis来实现。大体思路如下：&ensp;&ensp;&ensp;判断标识删除任务执行的Key是否存在，存在的话直接返回，不存在则使用 SETNX 尝试设置Key的value为当前自己的Pid，再次获取key对应的value值，若value和自己当前的pid不同，说明不是当前节点获取的锁，不能执行任务，只有value和当前自己的pid相同时才执行删除任务。这样就可以保证集群中只有一个节点执行了删除任务，在任务执行结束之后要删除key。下面给出流程图，思路一目了然。 4.在哪里触发任务&ensp;&ensp;&ensp;分析了如何定位以及删除数据，那我们如何触发任务的执行呢？这里我在配置文件中设置了一个开关，用来标识本次启动是否需要执行删除任务。这个开关和上面提到的redis key共同决定是否在当前节点执行任务。&ensp;&ensp;&ensp;什么时机进行删除呢？因为删除任务中使用了spring bean service，所以应该在spring容器初始化bean完成后执行删除任务。&ensp;&ensp;&ensp;可以通过实现 ApplicationRunner 接口，实现接口的run方法来执行我们的任务。查阅springboot官方文档@SpringbootDocdocs.spring.io/spring-boot/docs/2.1.4.RELEASE/reference/htmlsingle/#using-boot 二、代码实现&ensp;&ensp;&ensp;通过以上分析，实现思路已经非常清晰，下面给出实现代码，仅供参考。DeleteClockTask.java1234567891011121314151617181920212223@Slf4j@Datapublic class DeleteClockTask implements Runnable &#123; private String name; private List&lt;Long&gt; userIds; private ClockDeleteService clockDeleteService; public DeleteClockTask(String name, List&lt;Long&gt; userIds) &#123; this.name = name; this.userIds = userIds; this.clockDeleteService = (ClockDeleteService) SpringContextUtils.getBeanByClass(ClockDeleteService.class); &#125; @Override public void run() &#123; log.info("delete clock task &#123;&#125; start...", name); clockDeleteService.deleteUnusedClock(userIds); log.info("delete unused clock task &#123;&#125; end.", name); &#125;&#125; InitialBeanHandler.java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465@Component@Slf4jpublic class InitialBeanHandler implements ApplicationRunner &#123; @Autowired private ClockDeleteService clockDeleteService; @Value("$&#123;task.delete.status&#125;") private int deleteSwitch; @Autowired private RedissonHandler redissonHandler; private final static long TASK_EXPIRE_MILLS_TIME = 60 * 60 * 1000; private final static String DELETE_CLOCK_TASK_KEY = "delete_used_clock_running"; private final static ExecutorService pool = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors()); @Override public void run(ApplicationArguments args) throws Exception &#123; // 先判断删除开关是否开启 log.info("删除无用闹钟开关 deleteSwitch : " + deleteSwitch); // 若开关开启，并且当前没有节点在执行删除任务，则执行删除任务 //通过redis查询是否有节点已经运行了删除任务 boolean taskRunning = redissonHandler.exists(DELETE_CLOCK_TASK_KEY); List&lt;DeleteClockTask&gt; tasks = new ArrayList&lt;&gt;(); if (deleteSwitch == 1 &amp;&amp; !taskRunning) &#123; //当前节点执行删除任务，设置redis中的任务状态 String nowPid = ManagementFactory.getRuntimeMXBean().getName(); redissonHandler.setNX(DELETE_CLOCK_TASK_KEY, nowPid, TASK_EXPIRE_MILLS_TIME); String taskRunningPid = redissonHandler.get(DELETE_CLOCK_TASK_KEY, String.class); if (!StringUtils.equals(taskRunningPid, nowPid)) &#123; return; &#125; //获取分批删除的userId的list List&lt;List&lt;Long&gt;&gt; deleteUsersList = clockDeleteService.getDeleteUser(); if (CollectionUtils.isNotEmpty(deleteUsersList)) &#123; int size = deleteUsersList.size(); log.info("There are &#123;&#125; delete clock tasks totally.", size); for (int i = 0; i &lt; size; i++) &#123; List&lt;Long&gt; userIds = deleteUsersList.get(i); DeleteClockTask task = new DeleteClockTask("deleteTask" + i, userIds); tasks.add(task); &#125; &#125; //限流 RateLimiter rateLimiter = RateLimiter.create(2); for (DeleteClockTask task : tasks) &#123; log.info("delete clock task &#123;&#125; wait time &#123;&#125;", task.getName(), rateLimiter.acquire()); pool.execute(task); log.info("delete clock task &#123;&#125; finished.", task.getName()); &#125; log.info("delete clock tasks all finished"); //执行完成，将redis中标志任务执行状态的key删除 redissonHandler.del(DELETE_CLOCK_TASK_KEY); &#125; &#125;&#125; 三、线上执行&ensp;&ensp;&ensp;经过测试环境反复测试，最终挑了个风和日丽的日子，准备在生产环境执行。&ensp;&ensp;&ensp;合并master，开始部署，盯着日志，静静等待…&ensp;&ensp;&ensp;线上删除任务共分为了4014个组，按每秒钟2组的速度进入线程池,开始执行删除任务，观察cpu使用率，基本稳定，没有出现激增。半个多小时后，所有任务执行完成。一共删除了58115102条数据，至此这次删除历史数据的任务完成。&ensp;&ensp;&ensp;第一次在线上物理删除这么大量的数据，仅此记录一下本次处理的思路和实现方法。]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>线上</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记一次数据库更改字符集踩的坑]]></title>
    <url>%2F2019%2F04%2F19%2F%E8%AE%B0%E4%B8%80%E6%AC%A1%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9B%B4%E6%94%B9%E5%AD%97%E7%AC%A6%E9%9B%86%E8%B8%A9%E7%9A%84%E5%9D%91%2F</url>
    <content type="text"><![CDATA[最近接手了一个闹钟App的后端项目，其中有个功能就是用户可以将本地闹钟同步到服务器，以便更换设备后能从服务器同步数据到新设备。但是这几天观察后台日志发现，同步的时候总是ERROR，定位错误发现跟数据库的字符集有关，在此记录一下本次线上错误的排查过程。 一、定位ERROR通过Kibana查看最近的ERROR日志，可发现如下的错误描述。&ensp;&ensp;&ensp;很明显可以发现，是因为insert的时候插入的数据不符合该列的要求。进而查看插入的数据，定位到插入内容含有特殊字符，比如emoji表情和其他一些字符。查询table的字符集发现这张表是utf8字符集，并不是utf8mb4的字符集，所以报这个错也是很正常了。看到这里你可能会问，这个问题应该在很久之前就应该发现了，为什么这几天才把它揪出来呢？这个项目很早了，包括后端和客户端，经过客户端同学的代码筛查，发现由于历史的原因，客户端对同步的结果的处理存在bug，导致后台同步失败某冲情况下也会提示同步成功，所以前台并不会暴露这个问题。&ensp;&ensp;&ensp;所以当时建表使用的utf8字符集已经不能满足用户的自定义名称的需求，需要变更这张表的字符集为utf8mb4。但是一查数据，这张表就有七千多万的数据，更改字符集的话对之前的内容是否有影响，要执行多久？问题找到了，就开始找dba同学商量，最后决定先创建一张utf8mb4的新表，将原来的数据导入到新表，完成后，再将原表rename成新表，完成切换。说干就干，晚上提了工单，dba开始执行。 二、黎明前的黑暗&ensp;&ensp;&ensp;第二天早上起床，发现接到了n多条服务报警，正是昨天更改字符集的服务。到了公司立马查看服务日志，发现服务挂了，重新部署启动，没有两分钟又挂了。这是什么原因呢？没有更改任何代码，只更改了一个表的字符集，整个服务就崩了吗？这是什么道理，一时间也是很懵。这时候dba那边发来了一长串slow sql，是一个两个表的连表查询，一开始我并未用explain分析sql语句，因为sql较简单，发现语句的书写还算规范，该走的索引也会走，一时间也无法定位问题。&ensp;&ensp;&ensp;难道是昨天修改字符集之后，insert无异常，表的增量变大，查询变得更加慢了？根据这个猜测，为了临时解决这个问题，准备将这一小段代码修改成分表查询，在内存里聚合处理。正在准备拉分支修改代码的时候，dba同学那边发消息说是索引失效了。我赶紧explain了一下刚刚的sql语句，果然，之前应该走的索引在改了字符集之后就失效了。修改字符集之后的explain结果：修改字符集之前的explain结果：原来连表查询的时候，两个表的字符集不同会导致索引失效，所以在这个如此多数据的表中进行连表查询是一件灾难性的事。找到原因后，将连表查询的另一个表的字符集同样做出修改，之后索引正常，服务也正常了。 三、总结通过这次处理线上问题，深深体会到在表数据很多的时候进行连表查询是一件多么可怕的事情，一不小心就把数据库或者服务搞崩溃了。还有一点很关键，不要像我一样看到sql简单就理所当然地以为会按照理论的情况走索引，拿到有问题的sql，一定要仔细分析，使用工具，比如explain来辅助分析sql，这样才不会遗漏问题。后续我们会对这个项目进行重构，将所有连表查询改成单表查询，然后在内存中对数据做聚合。另外这个表的数据已经到达七千多万了，修改了正确的字符集之后表的增量会更大，分表的工作也迫在眉睫。本文仅此记录下问题排查经过，如果大家也遇到了类似的问题，希望可以进行参考。]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>线上</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于红黑树的学习笔记]]></title>
    <url>%2F2018%2F09%2F23%2F%E5%85%B3%E4%BA%8E%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[前一段时间组内技术分享，正好趁这个机会好好研究了一下红黑树。在这里写下学习红黑树的一些成果和体会。 一、什么是红黑树先看一下《算法导论》中对红黑树的定义。 每个节点或者是红色，或者是黑色 根节点是黑色 每一个叶子节点(最后的空节点)是黑色的 如果一个节点是红色的，那么它的孩子节点都是黑色的 从任意一个节点到叶子节点，经过的黑色节点是一样的 这5条红黑树的定义看过之后感觉自己还是不太懂什么是红黑树，个人觉得有这种感觉的原因是定义比较抽象，不容易让人理解。那么，我们就从另一个角度入手来理解红黑树。 1. 2-3树这里先介绍一下2-3树。因为2-3树和红黑树有一定的联系，对于理解红黑树会有很大的帮助，所以我们先来看一下2-3树相关的一些性质。首先，2-3树满足二分搜索树的性质。不同的是在2-3树中，存在两种节点。一种是有两个叶子节点的，我们称作“2节点”；另一种是有三个叶子节点的，我们称作“3节点”。 如下是一整颗2-3树的示例。需要强调的是2-3树是完全平衡的树，即从根节点到任意一个叶子节点的高度都是相同的。 2. 2-3树怎样保持完全平衡性向2-3树中添加一个节点，遵循向二分搜索树中添加节点的基本思路，插入节点比当前节点小，则向当前节点的左子树添加，否则向右子树添加。不过由于2-3树特殊的性质，当要向“2节点”添加节点时，将待插入的节点与该“2节点”进行融合，组成一个新的“3节点”，如下图所示。 如果要向“3节点”添加节点，同向“2节点”添加节点一样，先组成一个临时的4节点，之后再拆分成3个“2节点”，如图所示。如果要插入的“3节点”的父节点是一个“2节点”，通过上述步骤得到的拆分过成为父节点的“2节点”，需要向原“3节点”的父节点进行融合，组成新的“3节点”。过程如下图所示。如果要插入的“3节点”的父节点是一个“3节点”，大体思路相同，向父节点进行融合，只不过此时融合后成为一个临时的“4节点”，之后要再次进行拆分。过程如图所示。 如上所述，2-3树保持了完全的平衡性。说了这么长时间的2-3树，那么2-3树和红黑树之间到底有怎样的关系，下面我们具体来看一下。 3. 2-3树与红黑树对于2-3树中的“2节点”，对应于红黑树中的“黑节点”，即相当于普通二分搜索树中的一个节点。对于2-3树中的“3节点”，相当于普通二分搜索树中的两个节点融合在一起，我们如何来描述这种融合在一起的两个节点之间的关系呢？其实很简单，如果我们将连接这两个节点的边涂成红色，就可以表示这两个节点是融合的关系，即2-3树中的一个“3节点”。那么问题又来了，对于树这种数据结构，我们在定义的时候通常都是针对节点进行定义，并没有对节点之间的边进行定义，我们如何来表示这条被涂成红色的边呢？大家都知道，对于树中的任意一个节点，都是只有一个父亲节点，所以与其父节点相连接的边可以用该节点进行表示。那么我们就可以将这两个节点中较小的节点（作为左子树的节点）涂成红色，就可以很好地表示这两个节点融合的关系了。 综合以上描述，2-3树与红黑树之间的关系，我们可以用下图很好地进行表示。我们这里说的红色节点都是向左倾斜的。看过2-3树中的两种节点和红黑树中节点的对应关系后，我们就来看一下一棵2-3树与红黑树之间的对比，如图所示。 4. 红黑树的性质讨论了2-3树与红黑树之间的关系，我们再回过头来看一下红黑树的5条定义和性质，会发现很好理解了。 每个节点或者是红色，或者是黑色这条定义很好理解，在此不做解释。 根节点是黑色根据之前说过的，红色的节点对应于2-3树中“3节点”中较小的那个节点，拆成两个“2节点”的话则是一个左子树的节点，即红色的节点总是可以和其父节点进行融合，所以红色节点一定有父节点，显然根节点不能是红色，所以根节点是黑色。 每一个叶子节点(最后的空节点)是黑色的这条性质和第2条是对应的。对于叶子节点（最后的空节点），一颗空树的根节点也为黑色，所以与其说第三条是一条性质，不如说也是一个定义。 如果一个节点是红色的，那么它的孩子节点都是黑色的根据上面2-3树与红黑树两种节点的对比图，我们很容易看到，红色节点的两个子树，对应2-3树中的话，要么是一个“2节点”，要么是一个“3节点”，而不管是“2节点”还是“3节点”，相连的第一个节点都是黑色的，所以说红色节点的孩子节点都是黑色的。 从任意一个节点到叶子节点，经过的黑色节点是一样的根据2-3树与红黑树的关系对比图，可以发现，红黑树中一个黑色节点对应2-3树中一整个节点（“2节点”或“3节点”），而2-3树是完全平衡的树，从根节点到任意路径的叶子节点，经过的节点个数都是相同的，对应红黑树中，即从任意节点到叶子节点，经过的黑色节点是一样的。 二、 红黑树添加元素回忆刚刚提到的向2-3树中添加元素的过程，或者添加进一个“2节点”，形成一个“3节点”，或者添加进一个“3节点”，形成一个临时的“4节点”。理解了2-3树如何添加节点，对应红黑树就很好理解了。很容易知道，我们总是会将待插入的节点向父节点进行融合，所以我们将待插入的节点看成红色,即永远添加红色节点。向一棵空树添加节点42。插入后，该节点是根节点，根据红黑树的性质，根节点必须是黑色，所以讲该节点染成黑色。 若向如图的红黑树中添加节点37。因为37比42小，所以添加在42的左子树，对应2-3树中，形成一个“3节点”。若向如图的红黑树中添加节点42。因为42比37大，所以添加在37的右子树。这样的话红色节点就出现在了一个节点的右子树中，所以此时需要进行左旋转，让树满足红黑树的性质。 1. 左旋转对于一般的情况，如何进行左旋转呢？我们要对下图的红黑树进行左旋转。 首先将node节点与x节点断开，其次将x的左子树作为node的右子树。然后再将node作为x新的左子树，之后要把x的颜色染成node的颜色，最后将node的颜色变为红色，这样就完成了左旋转的操作。 2. 颜色翻转（flipColors）向红黑树中插入节点66，很容易知道插入到42右子树的位置，对应于2-3树的插入如图所示。 然而上面我们说到，我们总是要将新拆分出来的树的父亲节点向上进行融合，即这个父亲节点在红黑树中总是红色的，根据红黑树的性质，该父亲节点的两个孩子节点一定是黑色的。这样就需要将上一步形成的树进行颜色的翻转，变成如下图的形态。 3. 右旋转向如图的红黑树中插入节点12，根据二分搜索树插入的操作，此时会形成一条链状的结构，对于2-3树中则是变形成为图中的样子，才能保证平衡性。所以在红黑树中，也要通过变形，变成与2-3树对应的形态。这种情况的变形操作，称为“右旋转”。 一般的情况，右旋转操作同上面的左旋转操作很类似，下面我们一起来看一下过程。我们要对下图的红黑树进行右旋转的操作。首先将node和x节点断开，将x的右子树T1作为node的左子树。其次将node作为x的右子树。接着要把x的颜色染成原来node的颜色，把node染成红色。然后很显然，需要再进行一次颜色翻转操作，才能满足红黑树的性质。有一种比较复杂的情况，向下图的红黑树中插入节点40,要满足的红黑树的性质我们需要怎么操作呢？对应2-3树中最终的形态，第一步我们可以通过一次左旋转，变成下图的样子。会发现，这样就变成了上面说到的需要右旋转的形态，所以再进行一次右旋转和颜色翻转，就可以满足红黑树的性质了。 4.红黑树插入总结上面分情况讨论了向红黑树中添加节点的各种情况，这里总结一下。其实根据上面的讨论，我们可以发现，最后一种复杂的情况可以涵盖其余简单的情况，复杂的操作包含了左旋转、右旋转、颜色翻转，这三种操作，完全可以保持红黑树的性质。下面的一张图，很好的总结了向红黑树中添加节点不同情况下的过程。 三、红黑树删除元素关于红黑树的删除操作，比插入操作要复杂一些，需要分情况进行讨论。下面我们具体来看一下。红黑树的删除操作大体分为2步： 二分搜索树删除节点 删除修复操作 红黑树的删除首先满足二分搜索树的删除，然后对删除节点后的树进行修复操作，让其重新满足红黑树的5条性质。对于二分搜索树的删除，这里就不再赘述，我们主要讨论红黑树的删除修复操作。以下所说的当前节点意思是通过二分搜索树的方式删除要删除的节点后，代替原来节点的节点。当删除节点是红色节点时,那么原来红黑树的性质依旧保持，此时不用做修复操作。当删除节点是黑色节点时,情况很多，我们分情况讨论。 1.简单情况 当前节点是红色节点直接把当前节点染成黑色,结束，红黑树的性质全部恢复。 当前节点是黑色节点，并且是根节点什么都不做，直接结束。 2.复杂情况 N、S、SL、SR、P都为黑色其中N是上述的当前节点，S是N的兄弟节点，P是N的父节点，SL和SR是N兄弟节点的左右孩子节点。 此时将S染成红色，这样经过N路径的黑色节点就和N的兄弟子树中的黑色节点相同了，但是经过P节点的黑色节点少了一个，此时需要将P当做新的N再进行操作，具体怎么操作可以见以下一些情况。 N、S、SL、SR为黑色，P为红色 此时将P和S的颜色进行交换,P成为了黑色,它为经过节点N的路径添加了一个黑色节点，从而补偿了被删除的黑色节点。S的颜色只是上移到父节点P上,因而经过S节点路径的黑色节点的数目也没有发生改变。 N、S为黑色，SR为红色图中蓝色节点表示该节点可以为黑色也可以为红色，即对该节点的颜色没有要求。此时将以P为根的子树进行左旋转然后交换P和S的颜色将SR染成黑色调整后经由N的路径的黑色节点数比调整前增加了一个，恰好补偿了被删除的黑色节点。对于不经过N但经过其他节点的任意一个路径来说，它们贡献的黑色节点数目不变。 N、S为黑色，SL为红色，SR为黑色此时，将以S为根的子树进行右旋转接着交换S和SL的颜色节点SL的左孩子在旋转前后不变，而SL原来为红色，所以SL的左孩子必定为黑色。所以旋转后对于N节点来说，相当于情况3。之后再通过情况3中的描述进行操作。整体上情况4需要进行一次右旋转和一次左旋转。 N为黑色，S为红色此时，将以P为根的子树进行左旋转将P和S颜色交换经过这样的变换后，把该情形转化成了N为黑色，其兄弟为黑色的情形，再通过以上描述的几种情况进行变换，最终保持红黑树的性质。红黑树删除的各种复杂的情况，以上都进行了讨论，虽然比较繁琐，但是认真研究后还是可以理解的，并没有之前想象地那么困难。 四、红黑树的性能红黑树的增删改查的复杂度显然是O(logn)级别的，通常说红黑树是统计性能更优的树结构。为什么说统计性能更优呢？因为若是单纯的读操作，AVL树的性能比红黑树强一些，红黑树不是严格的平衡树，它是保持“黑平衡”的树。对于红黑树，最坏的情况，是树中最左侧的节点的左子树都是红色的节点，即对应2-3树中的“3节点”，所以这时红黑树的高度就是2logn（除了logn个黑色节点外，还有logn个红色节点），红黑树要比AVL树要高一些。所以从单纯的查询性能来说，红黑树的性能并没有AVL树强。对于插入删除操作来说，红黑树相比于AVL树减少了左旋转或右旋转的次数，所以红黑树的插入删除的性能比AVL树强一些。综合增删改查各方面的性能，红黑树的综合性能比较高。 五、红黑树的应用 Java中的TreeMap，Java8中HashMap的TreeNode节点采用了红黑树实现 C++中，STL的map和set也应用了红黑树 Linux中完全公平调度算法CFS(Completely Fair Schedule) 用红黑树管理进程控制块epoll在内核中的实现，用红黑树管理事件块 Nginx中，用红黑树管理timer等 这次的分享，主要对红黑树的性质以及向红黑树中插入、删除元素进行分析，对于红黑树的应用并没有很深入的进行研究，如上所述的几种红黑树的应用，也只是了解，还需要在以后的工作学习中进行完善。以上是本人对红黑树学习的一些成果和心得，记下来让自己所学的知识体系化，也方便日后的复习回顾。]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>红黑树</tag>
      </tags>
  </entry>
</search>

<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[不一样的tree-并查集]]></title>
    <url>%2F2020%2F12%2F07%2F%E4%B8%8D%E4%B8%80%E6%A0%B7%E7%9A%84tree-%E5%B9%B6%E6%9F%A5%E9%9B%86%2F</url>
    <content type="text"><![CDATA[&ensp;&ensp;&ensp;&ensp;很久没有更新文章了，周末又巩固了一下数据结构基础，这次我们来看一下有些不一样的树结构-并查集。 一、什么是并查集&ensp;&ensp;&ensp;&ensp;下图所示的一些节点，节点之间可以相连，如果想要知道某两个节点是否可以连通，这个问题如何解呢？&ensp;&ensp;&ensp;&ensp;这是典型的连接问题，像下图这种节点很少的情况，肉眼一看就会得到答案，但当有成千上万的节点时，又该如何解决问题呢？我们要说的并查集就是解决连接问题的一种解决方案。 &ensp;&ensp;&ensp;&ensp;并查集可以非常快速地判断网络中节点的连接状态。这里的网络是一个抽象的概念，比如可以是社交网络，那么人就是一个一个的节点，人与人之间的关系就是节点与节点之间的边，若要知道两个人之间是否有直接或间接的好友关系，就可以使用并查集来实现。 &ensp;&ensp;&ensp;&ensp;对于一组数据，并查集主要支持两个动作： union(p,q)在并查集内部，将p、q两个元素以及他们所在的集合合并起来。 isConnected(p,q)查询对于给定的两个数据p、q，他们是否属于同一个集合。 &ensp;&ensp;&ensp;&ensp;对于并查集的这两个动作，我们可以抽象出一个接口来表示。123456789101112131415161718192021222324252627282930313233/** * UnionFind并查集接口 * * @author renxiaoya * @date 2020-12-06 **/public interface UF &#123; /** * 获取并查集中有多少元素 * * @return 并查集中有多少元素 */ int getSize(); /** * 两个元素是否相连 * * @param p 元素编号p * @param q 元素编号q * @return 是否相连 */ boolean isConnected(int p, int q); /** * 将两个元素并在一起 * * @param p 元素编号p * @param q 元素编号q */ void unionElement(int p, int q);&#125; 这里我们的p和q指的是一个抽象的编号，可以理解为索引编号，比如isConnected(p,q)代表了编号为p的元素和编号为q的元素是否相连，至于p、q元素到底指的是什么，我们并不关心。接下来，我们来看看如何实现这个接口，实现并查集的功能。 二、并查集的实现&ensp;&ensp;&ensp;&ensp;假设有10个元素，编号从0到9，当然这些节点都是业务的抽象，可以是10个人、10辆车、10本书等等，具体的含义与不同的业务逻辑有关。在并查集的内部，我们只存这10个编号，表示具体的10个元素，每一个节点所存储的是它所属的这个集合的id。下图中，元素0所属的集合id为0，元素1所属的集合id为1，元素2所属的集合id为0，以此类推。不同的id值可以理解为不同的集合所对应的编号。下图的例子可以看成是把10个元素分成了两个集合，其中0，2，3，6，7，9这几个元素在一个集合中1，4，5，8这几个元素在另外的一个集合中。其实可以很容易的想到，我们可以使用一个数组来存储这样的结构，数组的索引就是对应的元素编号，索引所对应数组中的值就是集合的id。图中的元素0和元素2所对应的id值都为0，可以说元素0和元素2可以相连接。 Quick Find&ensp;&ensp;&ensp;&ensp;上面说到并查集主要的两个操作union(p,q)和isConnected(p,q)，对于数组存储的并查集来说，可以很容易的回答isConnected(p,q)，只需要看，数组索引p、q对应的值是否相同即可。这里我们把找到数组索引p或者q对应值的过程，也抽象为一个方法find(p)。那么判断isConnected(p,q)就转化为了判断find(p)与find(q)是否相等。 &ensp;&ensp;&ensp;&ensp;很显然，以上操作的时间复杂度是O(1)，对于这种存储的并查集，find这个操作是非常快的。 &ensp;&ensp;&ensp;&ensp;上面介绍了find的思路，接下来我们来看一下并查集另一个重要的动作union(p,q),我们可以称为Quick Union。&ensp;&ensp;&ensp;&ensp;还是以上面的并查集为例，如果想要实现union(1,2)，就需要把元素1所在集合与元素2所在集合合并起来，也就是说，这两个集合合并之后，集合中每一个元素对应的集合id值都是相同的。我们可以把元素1所在集合合并到元素2所在集合，也可以把元素2所在集合合并到元素1所在集合，要么全是0，要么全是1。 &ensp;&ensp;&ensp;&ensp;实现思路也很简单，先找到元素p、q对应的id，如果id已经是相等的，说明元素p、q已经在一个集合中，直接return即可；否则的话，遍历一遍当前数组，每次遍历，如果当前索引下标对应的值与元素p对应的id相等，此时将当前索引下标对应的值设置为元素q对应的id。&ensp;&ensp;&ensp;&ensp;因为遍历了一遍数组元素，所以union(p,q)的时间复杂度是O(n)。 &ensp;&ensp;&ensp;&ensp;因为find操作时间复杂度是O(1)，而union的时间复杂度是O(n)，所以这样实现的并查集我们也称为是Quick Find&ensp;&ensp;&ensp;&ensp;思路清楚了，下面我们看看代码如何实现Quick Find的并查集。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465/** * 并查集实现 - v1 * &lt;p&gt; * 0 1 2 3 4 5 6 7 8 9 * ------------------- * 0 1 0 1 0 1 0 1 0 1 * &lt;p&gt; * OP | 时间复杂度 * unionElement(p,q) --&gt; O(n) * isConnected(p,q) --&gt; O(1) * * @author renxiaoya * @date 2020-12-06 **/public class UnionFind1 implements UF &#123; private int[] id; public UnionFind1(int size) &#123; id = new int[size]; for (int i = 0; i &lt; id.length; i++) &#123; id[i] = i; &#125; &#125; @Override public int getSize() &#123; return id.length; &#125; @Override public boolean isConnected(int p, int q) &#123; return find(p) == find(q); &#125; @Override public void unionElement(int p, int q) &#123; int pId = find(p); int qId = find(q); if (pId == qId) &#123; return; &#125; for (int i = 0; i &lt; id.length; i++) &#123; if (id[i] == pId) &#123; id[i] = qId; &#125; &#125; &#125; /** * 查找元素p对应的集合编号 * * @param p 元素p * @return 集合编号 */ private int find(int p) &#123; if (p &lt; 0 || p &gt;= id.length) &#123; throw new IllegalArgumentException("p is out of bound."); &#125; return id[p]; &#125;&#125; &ensp;&ensp;&ensp;&ensp;以上，我们实现了Quick Find的并查集。既然有Quick Find，是否有Quick Union呢？答案是肯定的。接下来我们来看一看如改进上面的实现，来提高union操作的效率。 Quick Union&ensp;&ensp;&ensp;&ensp;上面实现的Quick Find好像和树没有任何关系，不要着急，我们来看看Quick Union的实现思路。&ensp;&ensp;&ensp;&ensp;我们把每一个元素都看作是一个节点，节点之间相连接，形成了一个树的结构。不过这里的树和之前实现的二叉树、trie等是不同的，在并查集中实现的树结构是孩子指向父亲的。 &ensp;&ensp;&ensp;&ensp;看个简单的示例。节点3与节点2相连接，其实就是节点3指向了节点2，而这里节点2是树的根节点，对于节点2，它指向自己。&ensp;&ensp;&ensp;&ensp;如果节点1想要和节点3合并，就把节点1指向节点3所在树的根节点，也就是节点2。 &ensp;&ensp;&ensp;&ensp;如果并查集中有一棵树是左边子树的样子，5和6节点指向7节点，此时想要将节点7与节点2进行合并，如何操作呢？实际上是将节点7所在树的根节点指向节点2即可。 &ensp;&ensp;&ensp;&ensp;如果我们想将节点7与节点3合并，得到的结果还是上图的样子，其实合并操作是将节点7所在树的根节点指向节点3所在树的根节点，也就是节点2。 &ensp;&ensp;&ensp;&ensp;以上就是真正并查集实现的思路，和上面Quick Find实现的存储发生了变化，实际上也是很简单的。通过观察，我们发现针对每一个节点，只有一个指针，只会指向另一个元素，对于这个指针的存储，我们依然可以使用数组的方式来存储。这个数组，我们可以叫作parent,parent[i]表示的就是第i个元素所在的节点指向了哪个元素。&ensp;&ensp;&ensp;&ensp;在初始化的时候，每一个节点都没有和任何一个节点合并，都指向了自己，也就是parent[i]都等于i。 &ensp;&ensp;&ensp;&ensp;当要执行union(4,3)时，将节点4指向节点3，对应parent数组，就是将parent[4]设置为parent[3]的值。 &ensp;&ensp;&ensp;&ensp;要执行union(3,8)，就是将节点3所在的树指向节点8，相应的parent[3]设置为8；执行union(6,5),就是将节点6指向节点5，parent[6]设置为5。 &ensp;&ensp;&ensp;&ensp;执行union(9,4)，就是将节点9指向节点4所在这棵树的根节点，这里涉及到了一个查询操作，查询节点4所在的根节点，我们先看节点4的父节点是3，不是4本身，继续查找节点3的父节点为节点8，也不是节点3本身，说明还不是这棵树的根节点，我们继续往下找，看节点8的父节点是8，与节点8本身相等，说明这是个根节点，此时我们便找到了节点4所在这棵树的根节点，也就是节点8。 &ensp;&ensp;&ensp;&ensp;上图中可以看到，节点9指向了节点8，我们为什么不直接指向节点4呢？很显然，指向节点4的话就形成了一个链表，之后如果再进行查找节点9所在树的根节点时，就等同于遍历了这个链表，树的优势就体现不出来了；而指向节点8时，当查找节点9所在树的根节点时，我们向上查1次就能得到结果。所以在数组中，parent[9]设置成8。 &ensp;&ensp;&ensp;&ensp;按照上面的规律，我们执行union(2,1)和union(5,0)，可以得到下图的结果。 &ensp;&ensp;&ensp;&ensp;执行union(7,2)和union(6,2)，前者很简单，无需多说，后者稍微复杂一些，我们要找到节点6所在树的根节点，让它指向节点2所在树的根节点，也就是节点0指向节点1。 &ensp;&ensp;&ensp;&ensp;以上的操作，是并查集通常的实现。通过分析，我们知道这种union操作的时间复杂度是O(h),h表示的是union的两个元素所在树深度的大小，通常这个深度的大小比元素的个数要小的多，所以这个union的过程相对来说会快一些；不过相应的代价就是查询操作，如果我们想知道节点5和节点4是否相连，我们要吵到节点5和节点4对应的根节点，比较两个根节点是否相等，这里节点5的根节点是1，节点4的根节点是8，1和8不相等，所以节点5和节点4不是相连的，这一查找的过程时间复杂度也是O(h)。我们通过牺牲了查询操作的性能提升了合并操作的性能，不过通常情况下，树的深度是远远小于元素的总数的，所以我们让查询和合并都是树的高度这个时间复杂度，在大多数情况下，性能是可以接受的。 &ensp;&ensp;&ensp;&ensp;知道了查找和合并的思路，下面我们来看看代码实现。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162/** * 并查集实现 - v2 * parent 0 1 2 3 4 5 6 7 8 9 * --------------------- * 1 1 0 3 4 5 6 6 5 9 * * Operate | 时间复杂度 * unionElement(p,q) --&gt; O(h) h: height of tree * isConnected(p,q) --&gt; O(h) h: height of tree * @author renxiaoya * @date 2020-12-06 **/public class UnionFind2 implements UF &#123; private int[] parent; public UnionFind2(int size) &#123; parent = new int[size]; for (int i = 0; i &lt; size; i++) &#123; parent[i] = i; &#125; &#125; @Override public int getSize() &#123; return parent.length; &#125; @Override public boolean isConnected(int p, int q) &#123; return find(p) == find(q); &#125; @Override public void unionElement(int p, int q) &#123; int pRoot = find(p); int qRoot = find(q); if (pRoot == qRoot) &#123; return; &#125; parent[pRoot] = qRoot; &#125; /** * 查找元素p对应的集合编号 * * @param p 元素p * @return p对应的元素编号 */ private int find(int p) &#123; if (p &lt; 0 || p &gt;= parent.length) &#123; throw new IllegalArgumentException("p is out of bound."); &#125; //不断地查找根节点 while (p != parent[p]) &#123; p = parent[p]; &#125; return p; &#125;&#125; 三、可以再优化吗&ensp;&ensp;&ensp;&ensp;上面我们实现了两种并查集，这两种实现的性能如何呢？我们来测试一下。 &ensp;&ensp;&ensp;&ensp;对于size=10000，进行10000次合并和10000次查询操作。具体测试代码这里就不贴出来了，来看结果吧。对比之下：1234UnionFind1 : 0.05409653sUnionFind2 : 0.035575485sProcess finished with exit code 0 &ensp;&ensp;&ensp;&ensp;上面结果差异并不明显，我们增加size，对于size=100000，进行10000次合并和10000次查询，结果变成了如下的情况： 1234UnionFind1 : 0.269145621sUnionFind2 : 0.003194141sProcess finished with exit code 0 &ensp;&ensp;&ensp;&ensp;如果我们把操作次数也设为100000，又会变成什么样呢？1234UnionFind1 : 5.205210688sUnionFind2 : 10.711065036sProcess finished with exit code 0 &ensp;&ensp;&ensp;&ensp;对于v1版本的并查集，我们就是使用数组的顺序遍历，是对一片连续的空间进行了一次循环的操作，这样的操作，jvm有很好的优化，所以运行速度会非常快。&ensp;&ensp;&ensp;&ensp;而对于v2版本的并查集来说，这个查询的过程其实是一个不断索引的过程，它不是一个顺次访问一片连续空间的过程，要在不同的地址空间进行跳转，因此速度会相对慢一些；再者，v2的并查集，find和union的复杂度都是O(h),我们增大了操作数，意味着在union的过程中，将更多的元素都组织在了一个集合中，这棵树就变得非常庞大，深度也有可能会非常高，导致我们进行这100000次操作的时候，isConnected消耗的时间也会比较多。所以这次的测试结果，v2版本的效率显得更慢一些。 针对size的优化&ensp;&ensp;&ensp;&ensp;其实对于v2版本的并查集，我们有很大的优化空间，我们回忆一下，在进行union操作的时候，是没有考虑树的特点就进行合并指向的，我们来看下面的过程。&ensp;&ensp;&ensp;&ensp;依次进行union(0,1),union(0,2),union(0,3)操作，我们的并查集变成了这个样子。 &ensp;&ensp;&ensp;&ensp;很明显，这样已经形成了一个链表，当我们继续进行union(0,n)，最终我们的并查集实际上就是一条长长的链表了。这种情况我们如何进行优化呢？ &ensp;&ensp;&ensp;&ensp;一个简单的思路，我们考虑当前节点所在的这棵树的节点多少，将节点少的这棵树合并到节点多的树上，就可以有效的降低树的高度。比如上述例子，我们进行union(0,3)时，比较一下节点0所在树的size（3）和节点3所在树的size（1），将size小的向size大的树合并，即将节点3指向节点2。 &ensp;&ensp;&ensp;&ensp;这样我们可以有效地降低树的高度。代码改造如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071/** * 并查集实现 - v3 * 与v2相比，优化了size，unionElement时，将节点数少的树指向节点数多的树 * * @author renxiaoya * @date 2020-12-06 **/public class UnionFind3 implements UF &#123; private int[] parent; /** * sz[i]表示以i为根的集合中元素的个数 */ private int[] sz; public UnionFind3(int size) &#123; parent = new int[size]; sz = new int[size]; for (int i = 0; i &lt; size; i++) &#123; parent[i] = i; sz[i] = 1; &#125; &#125; @Override public int getSize() &#123; return parent.length; &#125; @Override public boolean isConnected(int p, int q) &#123; return find(p) == find(q); &#125; @Override public void unionElement(int p, int q) &#123; int pRoot = find(p); int qRoot = find(q); if (pRoot == qRoot) &#123; return; &#125; // 若pRoot所在元素比qRoot所在元素少，将pRoot指向qRoot，并维护sz if (sz[pRoot] &lt; sz[qRoot]) &#123; parent[pRoot] = qRoot; sz[qRoot] += sz[pRoot]; &#125; else &#123; // 否则将qRoot指向pRoot parent[qRoot] = pRoot; sz[pRoot] += sz[qRoot]; &#125; &#125; /** * 查找元素p对应的集合编号 * * @param p 元素p * @return p对应的元素编号 */ private int find(int p) &#123; if (p &lt; 0 || p &gt;= parent.length) &#123; throw new IllegalArgumentException("p is out of bound."); &#125; while (p != parent[p]) &#123; p = parent[p]; &#125; return p; &#125;&#125; &ensp;&ensp;&ensp;&ensp;现在我们再来看看在size=100000，操作数也为100000的测试用例中，并查集的表现。12345UnionFind1 : 5.266835514sUnionFind2 : 11.177287476sUnionFind3 : 0.021229747sProcess finished with exit code 0 &ensp;&ensp;&ensp;&ensp;优化的效果是非常明显的，v3版本的并查集仅用了0.02秒就完成了操作。 基于rank的优化&ensp;&ensp;&ensp;&ensp;上面基于size的优化，我们考虑了树所在的节点个数多少来降低树的高度，那何不更直接的来比较树的高度呢？假设有如下的并查集，需要进行union(4,2)操作。 &ensp;&ensp;&ensp;&ensp;若按照size优化的思路，我们会将节点8指向节点7，因为节点4所在树的size比节点2所在树的size小，如下图所示： &ensp;&ensp;&ensp;&ensp;这样树的高度是4。如果我们直接来比较树的高度来进行合并呢？将高度低的向高度高的树合并，如下图所示： &ensp;&ensp;&ensp;&ensp;这样树的高度是3，比基于size的优化得到的树的高度更低。&ensp;&ensp;&ensp;&ensp;我们来看看代码如何实现，其实与size优化的代码很像，只是用一个int数组代表了以i为根的树的高度，合并的时候判断高度，将高度低的向高度高的树合并，并在合适的时候维护rank的值即可。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475/** * 并查集实现 - v4 * 针对rank优化，unionElement时，深度低的树指向深度高的树 * 这里是rank，排名、序的意思，不是绝对的高度 * * @author renxiaoya * @date 2020-12-06 **/public class UnionFind4 implements UF &#123; private int[] parent; /** * rank[i]表示以i为根的集合中元素的高度rank */ private int[] rank; public UnionFind4(int size) &#123; parent = new int[size]; rank = new int[size]; for (int i = 0; i &lt; size; i++) &#123; parent[i] = i; rank[i] = 1; &#125; &#125; @Override public int getSize() &#123; return parent.length; &#125; @Override public boolean isConnected(int p, int q) &#123; return find(p) == find(q); &#125; @Override public void unionElement(int p, int q) &#123; int pRoot = find(p); int qRoot = find(q); if (pRoot == qRoot) &#123; return; &#125; // 根据两个元素所在的树的rank不同判断合并的方向 // 将rank低的集合指向rank高的集合 if (rank[pRoot] &lt; rank[qRoot]) &#123; parent[pRoot] = qRoot; &#125; else if (rank[qRoot] &lt; rank[pRoot]) &#123; parent[qRoot] = pRoot; &#125; else &#123; // rank[qRoot] == rank[pRoot] parent[qRoot] = pRoot; rank[pRoot] += 1; &#125; &#125; /** * 查找元素p对应的集合编号 * * @param p 元素p * @return p对应的元素编号 */ private int find(int p) &#123; if (p &lt; 0 || p &gt;= parent.length) &#123; throw new IllegalArgumentException("p is out of bound."); &#125; while (p != parent[p]) &#123; p = parent[p]; &#125; return p; &#125;&#125; &ensp;&ensp;&ensp;&ensp;我们来测试一下基于rank的优化结果吧。由于前两种并查集实现的效率很低，这里就不进行测试了，我们来比较v3和v4的效率。&ensp;&ensp;&ensp;&ensp;我们增大数据量，拿size=10000000，操作数也为10000000来进行测试，结果如下：1234UnionFind3 : 4.168454361sUnionFind4 : 4.285047797sProcess finished with exit code 0 &ensp;&ensp;&ensp;&ensp;可以看到实际上基于size和基于rank的优化的结果是差不多的，只不过基于rank的优化在思路上更加顺一些，所以通常实现的并查集也使用基于rank的优化方案。 路径压缩&ensp;&ensp;&ensp;&ensp;有如下图的情况，这三种都可以表示并查集中相连的一些节点。我们执行isConnected来查询任意两个节点，都可以得到相同的结果，但是很显然，这些树的深度不同，对应的效率也是区别的。比如最左侧的树，高度达到了5，那么在进行find(4)的时候需要花费的时间就会比较长；而下面的这棵树，高度只有2，那么进行find(4)的操作速度就会很快。&ensp;&ensp;&ensp;&ensp;在我们上面实现的并查集中，进行union的过程，免不了会使树的高度越来越高，路径压缩就是可以将一棵树可以压缩成比较矮的树 &ensp;&ensp;&ensp;&ensp;我们在进行find操作的时候，会依次向上查询根节点，如果在向上查询的过程中，我们同时进行路径压缩，是否可以降低树的高度呢？&ensp;&ensp;&ensp;&ensp;下图中的并查集，我们进行find(4)操作。&ensp;&ensp;&ensp;&ensp;如果当前节点不是根节点，那么我们执行parent[i] = parent[parent[i]]操作，即将当前节点的父节点，指向父节点的父节点，文字描述比较绕，看图就比较清晰了。&ensp;&ensp;&ensp;&ensp;节点4不是根节点，将节点4的父节点指向其父节点也就是节点3的父节点–节点2。 &ensp;&ensp;&ensp;&ensp;节点2不是根节点，将节点2的父节点指向其父节点也就是节点1的父节点–节点0。 &ensp;&ensp;&ensp;&ensp;经过上述的操作，就将高度为5的树压缩成了高度为3，完成了一次路径压缩。&ensp;&ensp;&ensp;&ensp;代码也是很简单的，在基于rank优化的代码中，我们改造find方法,判断节点p是否是根节点，不是的话就执行parent[i] = parent[parent[i]]。12345678910private int find(int p) &#123; if (p &lt; 0 || p &gt;= parent.length) &#123; throw new IllegalArgumentException("p is out of bound."); &#125; while (p != parent[p]) &#123; parent[p] = parent[parent[p]]; p = parent[p]; &#125; return p;&#125; &ensp;&ensp;&ensp;&ensp;我们用同样的测试用例再来看看我们路径压缩的优化效果。12345UnionFind3 : 4.289546148sUnionFind4 : 4.266191791sUnionFind5 : 3.837546687sProcess finished with exit code 0 &ensp;&ensp;&ensp;&ensp;我们进行路径压缩的过程中，其实我们树的高度是降低的，但是并没有去维护rank数组的值，其实这是合理的，这也是这个数组取名rank，而不是height的原因，它表示的其实是一个排名，当我们进行路径压缩的时候，这个rank就不是严格意义上的树的高度了，它仅代表了树的一个排名。同一棵树不同节点对应的rank值可能是不同的，但是整体上的排名是一定的，这个排名依然可以用作union操作判断的依据。这里不做rank的维护，也是出于对性能的考虑，不维护的情况下已经可以胜任判断排名的依据，就无需费时去管理每一个节点的rank值使同一棵树的节点rank保持一致。 &ensp;&ensp;&ensp;&ensp;以上，我们一步步优化，实现了5个版本的并查集，相信还有不同思路的优化实现，比如路径压缩有很多种方法，我们只实现了一种，还可以使用递归来实现等等。&ensp;&ensp;&ensp;&ensp;到此为止，并查集的内容就介绍完了，记录下学习的历程，相信对自己也是很大的提高。]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简单聊聊Puppet Manager的实现]]></title>
    <url>%2F2020%2F06%2F16%2F%E7%AE%80%E5%8D%95%E8%81%8A%E8%81%8APuppet%20Manager%E7%9A%84%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[&ensp;&ensp;&ensp;&ensp;今天我们来聊一聊最近参与的一个开源项目。 &ensp;&ensp;&ensp;&ensp;这里借用java-wechaty的maintainer犀利豆的博客介绍一下wechaty是什么，以及java版本的前世今生。 犀利豆终于有一个Java可以用的微信机器人了 背景&ensp;&ensp;&ensp;&ensp;参与开发java-wechaty有一个多月的时间，在开发的过程中，不免要进行自测。在前期没有token调试不便的情况下，就想借助单测对所写代码进行验证，但是我发现想要进行单测也不是一件容易的事情。与以往 java web 开发不同，没有Spring封装好的带有上下文的test。于是，我借鉴ts版本wechaty的mock模块，实现了java-wechaty的mock puppet，专门用于测试wechaty上层代码逻辑。开心地实现完成mock puppet之后，又发现了新的问题。那就是现有java版本的wechaty在初始化puppet的时候，在代码中写死了hostie puppet，也就是图中的GrpcPuppet。 &ensp;&ensp;&ensp;&ensp;这样的话，我就无法初始化mock puppet了，所以我就思考能不能有一个manager来管理puppet的具体实现。有了这个想法，那么如何进行优雅的实现呢？接下来我们简单来聊聊。 实现思路 PuppetManager来管理具体的puppet实现类 在wechaty中通过调用PuppetManager的实例化方法，初始化出需要的puppet实现 可使用反射机制处理puppet和具体实现类 &ensp;&ensp;&ensp;&ensp;使用上述思路的改造，wechaty初始化的流程就变成了下图的样子。 &ensp;&ensp;&ensp;&ensp;可以看到，在wechaty的initPuppet()方法中，不再是直接初始化GrpcPuppet，而是使用了PuppetManager的resolveInstance()方法拿到了初始化过的puppet实现。&ensp;&ensp;&ensp;&ensp;那么PuppetManager具体是怎么实现的呢？其实很简单，直接看代码。 const val REFLECTION_BASE_PACKAGE = "io.github.wechaty" class PuppetManager { companion object { private val log = LoggerFactory.getLogger(PuppetManager::class.java) @JvmStatic fun resolveInstance(wechatyOptions: WechatyOptions): Future&lt;Puppet&gt; { log.info("PuppetManager resolveInstance(${JsonUtils.write(wechatyOptions)})") val reflections = Reflections(ConfigurationBuilder().setUrls(ClasspathHelper.forPackage(REFLECTION_BASE_PACKAGE, Thread.currentThread().contextClassLoader))) val subTypes: Set&lt;*&gt; = reflections.getSubTypesOf(Puppet::class.java) if (subTypes.isEmpty()) { throw java.lang.RuntimeException("expect one puppet,but can not found any one.") } if (subTypes.size &gt; 1) { throw RuntimeException("expect one puppet,but found ${subTypes.size}") } val clazz = subTypes.first() as Class&lt;*&gt; val declaredConstructor = clazz.getDeclaredConstructor(PuppetOptions::class.java) return CompletableFuture.completedFuture(declaredConstructor.newInstance(wechatyOptions.puppetOptions!!) as Puppet) } } } &ensp;&ensp;&ensp;&ensp;首先定义了一个基础的包路径，在该路径下使用reflections库，扫描所有实现了Puppet的类。因为我们必须需要一个puppet具体实现类，所以当我们扫描不到任何puppet的实现时，会抛出异常，告知开发者期望有一个puppet实现类，但是在classpath下并没有找到。 &ensp;&ensp;&ensp;&ensp;其次，当前我们只支持单次实例化一种puppet实现，所以当在路径下扫描到多于1个puppet实现类时，同样会抛出异常，提示开发者classpath中存在一个以上的puppet实现。 &ensp;&ensp;&ensp;&ensp;上面两种情况均未抛出异常的，说明manager已经找到了需要实例化的puppet实现，接下来就使用java反射，直接实例化即可。 &ensp;&ensp;&ensp;&ensp;以上就是manager实例化puppet的简单实现。 展望&ensp;&ensp;&ensp;&ensp;首次引入manager的版本中，我们把之前引入到wechaty sdk中的hostie puppet实现拿了出来，在sdk中仅引入puppet定义层。这样，使用者需要哪种puppet实现，自己引入即可，作为sdk就不再关心了。&ensp;&ensp;&ensp;&ensp;但是这样又增添了使用者的使用门坎，不如之前仅引入sdk包就能使用方便，所以在接下来的版本中，我们还是打算在sdk中使用hostie puppet作为puppet的默认实现，如果使用者有使用其他puppet实现类的诉求，需要手动在pom中exclude掉hostie puppet的默认实现，然后引入需要的puppet实现即可。 &ensp;&ensp;&ensp;&ensp;后续可能会支持多个puppet，那么manager就需要适当的改造去适配多个puppet实现。这里有一个简单的设计思路，在puppet定义层，我们可以定义一个mapping()方法，该方法的意思是作为一个puppet，我需要如何的映射才能初始化。那么具体怎么映射就交给子类，也就是具体的puppet实现类自己去实现。在manager中，我们只需要使用puppet定义层的mapping()方法就可以实现对子类的映射处理，作为manager，并不用关心当前到底是谁在初始化。下图是大体的结构。 &ensp;&ensp;&ensp;&ensp;有了PuppetManager，我们的java-wechaty实现得更加优雅了一些，而且实现了mock puppet，后续就可以通过单测提高代码的质量，提升稳定性，相信我们的java-wechaty会越来越完善。&ensp;&ensp;&ensp;&ensp;如果你对wechaty感兴趣，恰巧又是java developer，对java-wechaty有自己的想法或对目前的代码实现有任何好的建议，期待你的加入，为java-wechaty贡献代码~]]></content>
      <categories>
        <category>Wechaty</category>
      </categories>
      <tags>
        <tag>Wechaty</tag>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[内功修炼-线段树（二）]]></title>
    <url>%2F2020%2F04%2F02%2F%E5%86%85%E5%8A%9F%E4%BF%AE%E7%82%BC-%E7%BA%BF%E6%AE%B5%E6%A0%91%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[&ensp;&ensp;&ensp;&ensp;上篇我们认识了线段树，并创建了一棵线段树，这篇我们继续来看如何在线段树中查询和更新。 一、区间查询&ensp;&ensp;&ensp;&ensp;我们创建线段树的时候，利用了树的天然递归特性，进行查询我们同样可以使用递归的思想。&ensp;&ensp;&ensp;&ensp;定义一个 query 方法，queryL 参数表示查询区间的左边界，queryR 参数表示查询区间的右边界。首先考虑超出边界的异常情况，抛出相应异常。接下来就是我们核心的递归方法。&ensp;&ensp;&ensp;&ensp;我们可以思考一下，定义这个递归函数，需要哪些必要的条件呢？ 当前递归中正在处理的线段树 如何表示正在处理的线段树？指出当前树的根以及其左右边界即可。 正在处理的线段树的根节点索引（treeIndex） 正在处理的线段树的左边界（l） 正在处理的线段树的右边界（r） 我们最终需要查询的区间 区间查询左边界（queryL） 区间查询右边界（queryR） &ensp;&ensp;&ensp;&ensp;所以我们的递归方法可以定义以上这 5 个参数。&ensp;&ensp;&ensp;&ensp;定义好了方法，如何进行具体的查询操作呢？&ensp;&ensp;&ensp;&ensp;首先考虑递归终止的条件，即我们正在处理的线段树的左边界等于需要查询的左边界，并且正在处理的线段树的右边界等于需要查询的右边界，此时，线段树中的节点 tree[treeIndex] 即为方法的结果。&ensp;&ensp;&ensp;&ensp;接下来考虑递归的逻辑。和创建线段树一样，先找到当前处理树的中间节点索引和左右子树的索引。之后有以下几种情况： 查询左边界在中间节点索引 + 1的位置或还靠右，即 queryL &gt;= mid + 1此时去右子树，从中间位置 mid + 1 到 r 的区间去查询 queryL 到 queryR 查询右边界在中间节点索引的位置或还靠左，即 queryR &lt;= mid 此时去左子树，从 l 到 中间位置 mid 的区间去查询 queryL 到 queryR 查询的左右边界涉及左右子树的结果此时左右子树均涉及，需要在左子树查询 queryL 到 mid 区间，在右子树查询 mid + 1 到 queryR 区间，之后将左右结果聚合即可。 &ensp;&ensp;&ensp;&ensp;具体代码如下： /** * 返回区间[queryL...queryR]的值 * * @param queryL 左边界 * @param queryR 右边界 * @return 返回值 */ public E query(int queryL, int queryR) { if (queryL &lt; 0 || queryL &gt;= data.length || queryR &lt; 0 || queryR &gt;= data.length || queryL &gt; queryR) { throw new IllegalArgumentException("Index is illegal."); } return query(0, 0, data.length - 1, queryL, queryR); } /** * 在以 treeIndex 为根的线段树[l...r]中的范围里，搜索区间[queryL...queryR]的值 * * @param treeIndex 正在处理的树的根节点索引 * @param l 正在处理的线段树的左边界 * @param r 正在处理的线段树的右边界 * @param queryL 查询左边界 * @param queryR 查询右边界 * @return 搜索到的值 */ private E query(int treeIndex, int l, int r, int queryL, int queryR) { if (l == queryL &amp;&amp; r == queryR) { return tree[treeIndex]; } int mid = l + (r - l) / 2; int leftTreeIndex = leftChild(treeIndex); int rightTreeIndex = rightChild(treeIndex); if (queryL &gt;= mid + 1) { return query(rightTreeIndex, mid + 1, r, queryL, queryR); } else if (queryR &lt;= mid) { return query(leftTreeIndex, l, mid, queryL, queryR); } E leftResult = query(leftTreeIndex, l, mid, queryL, mid); E rightResult = query(rightTreeIndex, mid + 1, r, mid + 1, queryR); return merger.merge(leftResult, rightResult); } 二、区间更新&ensp;&ensp;&ensp;&ensp;区间查询实现了，我们再来看看另一个重要的操作 - 区间更新。 &ensp;&ensp;&ensp;&ensp;区间更新，顾名思义，将某个索引位置的值更新之后，与之关联的区间都要有所更新，所以叫区间更新。&ensp;&ensp;&ensp;&ensp;我们定义一个set方法，将索引位置 index 的值更新为 e。更新的思路其实很简单： 更新 data 数组相应索引的值 更新线段树 tree 数组相关联的节点值 &ensp;&ensp;&ensp;&ensp;更新 data 数组很简单，直接将 data[index] 赋值成 e 即可。&ensp;&ensp;&ensp;&ensp;我们主要看一下如何更新 tree 数组的节点值。&ensp;&ensp;&ensp;&ensp;由于更新某个位置的节点的同时，其父辈节点也要做出相应的改变，所以我们依然可以利用树的递归特性来更新。&ensp;&ensp;&ensp;&ensp;定义一个递归方法，有了之前的经验，应该很好理解，直接看代码： /** * 将 index 位置的节点更新成 e * * @param index 待更新节点的索引值 * @param e 要更新成的值 */ public void set(int index, E e) { if (index &lt; 0 || index &gt;= data.length) { throw new IllegalArgumentException("Index is illegal."); } //首先更新 data 对应索引的值 data[index] = e; //更新 tree 数组（线段树）中所有关联的值 set(0, 0, data.length - 1, index, e); } /** * 在以 treeIndex 为根的线段树中更新 index 的值为 e * * @param treeIndex 正在处理的线段树的根节点索引 * @param l 左边界 * @param r 右边界 * @param index 待更新的索引值 * @param e 要更新成的值 */ private void set(int treeIndex, int l, int r, int index, E e) { if (l == r) { tree[treeIndex] = e; return; } int mid = l + (r - l) / 2; int leftTreeIndex = leftChild(treeIndex); int rightTreeIndex = rightChild(treeIndex); if (index &gt;= mid + 1) { //index 比中间节点位置还靠右，去右子树操作 set(rightTreeIndex, mid + 1, r, index, e); } else { //否则去左子树操作 set(leftTreeIndex, l, mid, index, e); } //set过相应节点的值后不要忘记合并左右子树的结果，否则被操作的节点的父辈节点值将不会更新 tree[treeIndex] = this.merger.merge(tree[leftTreeIndex], tree[rightTreeIndex]); } &ensp;&ensp;&ensp;&ensp;这里需要特殊注意一点，在调用完左或右子树的 set 方法之后，一定不要忘记将调整后的左右子树的结果进行合并，并赋值给 tree[treeIndex]，否则被更新的节点的父辈节点将不会进行更新。 &ensp;&ensp;&ensp;&ensp;到此，线段树的区间查询和区间更新我们都实现了。 三、相关问题&ensp;&ensp;&ensp;&ensp;我们建立好了线段树的数据结构，就可以利用线段树来解决相应的问题。&ensp;&ensp;&ensp;&ensp;比如上一篇文章中提到的，查询2019年注册用户里截至目前消费额最高的用户，这里我们可以将用户消费额信息包装成对象，当做线段树中的节点，data 的长度就是所有用户的数量，创建线段树，merger 实现这里是选出消费额最大值。伴随用户消费额的改变，使用区间更新的操作更新线段树相应节点的值（时间复杂度 O(logn)），比从头到尾遍历的更新（时间复杂度 O(n)）效率更高。&ensp;&ensp;&ensp;&ensp;当然这里只是一个思路，具体实现会有更加细节的考虑。 思考 如何对一个区间进行更新 比如将区间 [2,5] 中所有元素 +5。 &ensp;&ensp;&ensp;&ensp;首先可以通过 O(logn) 的时间复杂度找到 A[2…3] 和 A[4…5] 这两个节点，以求和业务为例，这两个节点都包含2个元素，每个元素都需要 +5，所以这两个节点每个都要加 5*2=10 ，在回溯回去的时候，相应的这两个节点的祖辈节点也需要进行更新。需要注意，我们不能只更新中间节点（即涉及到的非叶子节点），图中红色标识的节点其实是要做 +5 操作的，如果我们对这些叶子节点同时也进行更新的话，其实我们进行了一次 O(n) 复杂度的操作，这个操作相对来说是比较慢的。 &ensp;&ensp;&ensp;&ensp;此时我们其实可以先不更新叶子节点的值，先使用一个数组 lazy 来记录未更新的内容，有了这个记录我们就不需要实际地去更新这些节点，当我们再有一次更新或查询操作再次碰到这些节点的时候，根据 lazy 记录判断，是否有需要更新的内容未更新，先更新之后再进行之后的操作，这种操作是一种懒惰更新的思想。这样以来，我们对于更新一个区间的操作，时间复杂度又变成了 O(logn) 数据量如此大的情况，我们是否还需要按照上面的方式创建 4n 大小的空间 &ensp;&ensp;&ensp;&ensp;这样浪费的空间就会很多，出于这个考虑，我们能否将上面的结构改用链式存储？ &ensp;&ensp;&ensp;&ensp;比如给定一个区间 [0,100000000]，而我们需要关注 [15,20] 区间的数据，此时如果建立 4n 的空间，将是浪费了很多很多空间，这时候我们可以根据需要动态地进行构建线段树。大体思路如下图： 根据关注区间，分段创建线段树，这样节省了很多空间而且也减少了一些无用的递归操作。 &ensp;&ensp;&ensp;&ensp;关于线段树我们先讨论这么多，主要知道线段树能够解决哪些问题和背后的一些思想。当然线段树也是一种比较高级的数据结构，能够探索的地方还有很多很多，我们只是讨论了一些基础的定义和思想。能够把这些看似基础抽象的数据结构与实际应用关联，其实也是很有意思的事情。]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[内功修炼-线段树（一）]]></title>
    <url>%2F2020%2F03%2F30%2F%E5%86%85%E5%8A%9F%E4%BF%AE%E7%82%BC-%E7%BA%BF%E6%AE%B5%E6%A0%91%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[&ensp;&ensp;&ensp;&ensp;前一阵子朋友换工作，去了新公司的一个基础服务的部门。对数据结构和算法的要求着实不低，不是平常的CRUD，而是通过各种巧妙的数据结构去完成对应的业务需求。我发现是时候夯实一下基础了，这次来看一下树结构中的线段树。 一、什么是线段树&ensp;&ensp;&ensp;&ensp;有一种很经典的线段树问题：区间染色。&ensp;&ensp;&ensp;&ensp;讲的是有一面长度为 n 的墙，每次选择一段儿墙进行染色。&ensp;&ensp;&ensp;&ensp;在染色的过程中，会有一部分被重复染色，那么 m 次操作后，我们可以看见多少种颜色呢？在 [i,j] 区间内可以看见多少种颜色呢？&ensp;&ensp;&ensp;&ensp;我们可以知道上述的问题是对区间进行以下的操作： 更新区间（染色操作） 查询区间（查询操作）&ensp;&ensp;&ensp;&ensp;通过上面的图片描述，我们很容易可以想到利用数组来实现，对于染色操作和查询操作时间复杂度均是是 O(n)。&ensp;&ensp;&ensp;&ensp;其实更普遍一点，这一类问题的实质，是基于区间的统计查询。比如一个电商网站，需要看2019年的注册用户消费额最高的用户。这里需要注意，我们关注的是动态的情况，是看在2019年注册的用户在到现在为止消费额的统计量，并不是说在单单在2019年消费最高的。如果是单单2019年消费最高的统计，直接拿出2019年的数据进行统计即可，因为2019年的数据已经是定值了。我们考虑的是动态的情况，是伴随更新的同时进行查询，即既有更新又有查询的操作，此时，使用线段树是一种好的选择。当然依然可以使用普通数组进行实现，只不过使用线段树的时间复杂度会低一些。 使用数组实现 使用线段树 更新 O(n) O(logn) 查询 O(n) O(logn) &ensp;&ensp;&ensp;&ensp;我们总结以上讨论的问题场景： &ensp;&ensp;&ensp;&ensp;对于给定的区间，支持以下两种操作。 更新： 更新区间中一个元素或者一个区间的值 查询一个区间 [i,j] 的最大值、最小值，或者区间数字和等。 &ensp;&ensp;&ensp;&ensp;那么我们怎么抽象出线段树的数据结构呢？&ensp;&ensp;&ensp;&ensp;通过上面的说明，我们是不会像线段树中进行添加和删除元素的，即区间的长度是固定不变的，只是区间中的元素可能会发生变化。所以我们可以使用一个静态数组来表示，线段树具体就是下面的样子。和普通二叉树的区别是，每一个节点所表示的是一个区间内的信息。以求合为例，每一个节点存储的是每个区间相应的数字和，根节点是整个区间的数字和，之后往下分成两个子区间，以此类推，直到最后叶子节点是单个的数字。 &ensp;&ensp;&ensp;&ensp;当我们需要求[4…7]区间的和，可以很方便的从树中找到，并不需要对数组进行挨个遍历。 二、线段树的表示&ensp;&ensp;&ensp;&ensp;在上面线段树有8个叶子节点，比较特殊，正好是一个满的二叉树，如果有10个元素，线段树是下面的情况：&ensp;&ensp;&ensp;&ensp;当一个节点不能平均分的时候，这里把这个节点分成一个节点少一点，一个节点多一点。&ensp;&ensp;&ensp;&ensp;所以，线段树不是完全二叉树，但是是平衡二叉树。&ensp;&ensp;&ensp;&ensp;为了简便，其实我们可以把线段树看作是一棵满的二叉树，只不过最后一层的叶子点有些是空的。满的二叉树我们可以很方便的用数组来表示，那么问题来了，我们需要多少节点来表示这课树呢？&ensp;&ensp;&ensp;&ensp;根据满二叉树的节点规律，我们可以看到每一层的节点和层数是有如下的关系的： 0层：1 1层：2 3层：4… h-1层：2^(h-1)&ensp;&ensp;&ensp;&ensp;根据等比数列求合公式，可得出，对满二叉树，h 层，一共有 2^h - 1 个节点，大约是 2^h，这里富裕一个节点，肯定可以放下 2^h - 1 个节点。&ensp;&ensp;&ensp;&ensp;最后一层（h-1层），有 2^(h-1) 个节点。&ensp;&ensp;&ensp;&ensp;可以看到，最后一层的节点数大致等于前面所有层节点之和。&ensp;&ensp;&ensp;&ensp;有了上面的结论，如果区间有 n 个元素，用数组描述线段树需要有多少节点呢？ &ensp;&ensp;&ensp;&ensp;通过上面的推导，如果区间有 n 个元素，需要 4n 的空间来存储整个线段树。由于我们不考虑添加元素，即区间是固定的，所以使用 4n 的静态空间即可。 &ensp;&ensp;&ensp;&ensp;当然 4n 是一个估计值，这 4n 的空间并不是都被占满的，我们留有空余。比如下图的情况，最后一层大部分的节点是 null。 &ensp;&ensp;&ensp;&ensp;我们暂不考虑这种浪费的问题。对于现代计算机来说，多出来的这些节点基本是不影响空间的，这里就是算法的空间换时间的体现。 三、创建线段树&ensp;&ensp;&ensp;&ensp;有了上面的分析，具体的代码实现其实很简单。data 是存储元素的数组，tree 是树结构使用的数组。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293public class SegmentTree&lt;E&gt; &#123; private Merger&lt;E&gt; merger; /** * 树结构 - 这里使用数组 */ private E[] tree; /** * 真正的数据 */ private E[] data; public SegmentTree(E[] arr, Merger&lt;E&gt; merger) &#123; this.data = (E[]) new Object[arr.length]; for (int i = 0; i &lt; arr.length; i++) &#123; data[i] = arr[i]; &#125; // 通过归纳，4倍的data长度用来创建线段树比较合适，可能会有空间的浪费，但是可以接受 tree = (E[]) new Object[4 * arr.length]; this.merger = merger; // 创建线段树 buildSegmentTree(0, 0, arr.length - 1); &#125; private void buildSegmentTree(int treeIndex, int l, int r) &#123; ... ... &#125; /** * 获取数据大小 * * @return 数据大小 */ public int getSize() &#123; return data.length; &#125; /** * 根据索引获得数据 * * @param index 索引值 * @return 数据 */ public E get(int index) &#123; if (index &lt; 0 || index &gt;= data.length) &#123; throw new IllegalArgumentException("Index is illegal."); &#125; return data[index]; &#125; /** * 返回一个索引表示的元素的左孩子的索引 * * @param index 索引值 * @return 左孩子的索引 */ public int leftChild(int index) &#123; return 2 * index + 1; &#125; /** * 返回一个索引表示的元素的右孩子的索引 * * @param index 索引值 * @return 右孩子的索引 */ public int rightChild(int index) &#123; return 2 * index + 2; &#125; @Override public String toString() &#123; StringBuilder res = new StringBuilder(); res.append("["); for (int i = 0; i &lt; tree.length; i++) &#123; if (tree[i] != null) &#123; res.append(tree[i]); &#125; else &#123; res.append("null"); &#125; if (i != tree.length - 1) &#123; res.append(", "); &#125; &#125; res.append("]"); return res.toString(); &#125;&#125; &ensp;&ensp;&ensp;&ensp;下面具体分析一下如何 build 线段树的节点。&ensp;&ensp;&ensp;&ensp;我们利用树的递归结构来创建，treeIndex 表示正在创建的线段树的根节点的索引，l 表示区间的左边界，r 表示区间的右边界。递归终止的条件就是当左边界等于右边界（l == r）时，这时要构建的树 tree[treeIndex] 就是 元素数组对应的索引的值（data[l] 或 data[r]）。之后找到当前线段树的左右子树的根节点索引和索引中间值 mid，接下来就是递归调用该方法，先创建左子树，后创建右子树，之后合并两棵子树得到正在创建的树的根节点数据。代码如下： 12345678910111213141516171819202122/** * 在 treeIndex 的位置创建表示区间[l...r]的线段树 * * @param treeIndex 正在创建的线段树的根节点 * @param l 表示区间的左边界 * @param r 表示区间的右边界 */ private void buildSegmentTree(int treeIndex, int l, int r) &#123; if (l == r) &#123; tree[treeIndex] = data[l]; return; &#125; int leftTreeIndex = leftChild(treeIndex); int rightTreeIndex = rightChild(treeIndex); int mid = l + (r - l) / 2; buildSegmentTree(leftTreeIndex, l, mid); buildSegmentTree(rightTreeIndex, mid + 1, r); tree[treeIndex] = merger.merge(tree[leftTreeIndex], tree[rightTreeIndex]); &#125; &ensp;&ensp;&ensp;&ensp;代码中的 merger 是对于合并这个操作的抽象，因为我们的线段树结构是一个通用的结构，不可能仅支持求合或求积的操作，这里就利用 java 的多态性，使用接口来抽象这个合并操作。具体的业务可以通过实现这个接口来实现自己的逻辑。 public interface Merger&lt;E&gt; { E merge(E a, E b); } &ensp;&ensp;&ensp;&ensp;以上，我们就完成了线段树的创建。&ensp;&ensp;&ensp;&ensp;在下篇文章中，我们将看如何在线段树中进行查询和更新操作。]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[谈谈SpringBoot的监听器]]></title>
    <url>%2F2020%2F01%2F17%2F%E8%B0%88%E8%B0%88SpringBoot%E7%9A%84%E7%9B%91%E5%90%AC%E5%99%A8%2F</url>
    <content type="text"><![CDATA[&ensp;&ensp;&ensp;&ensp;最近在看SpringBoot的源码，在SpringBoot项目启动的过程中，监听器在不同阶段都会监听相应的事件，今天我们就来谈谈SpringBoot启动过程中的监听器。 一、监听器扫盲&ensp;&ensp;&ensp;&ensp;监听器模式，顾名思义就是某个对象监听某个或某些事件的触发，然后做出相应的操作。这句话可以看出，监听器模式包含几个特定的元素： 事件，即监听什么（Event） 监听者，即谁来监听（Listener） 广播器，即谁来发布事件（Multicaster） 事件触发机制，即事件什么时候发布 整体的原理如下所示。&ensp;&ensp;&ensp;&ensp;当系统运行在某些关键节点的时候，会通过广播器去发布一些事件，而系统中存在着一些监听器，对某些事件感兴趣，去订阅这些事件。当这些事件被发布出去之后，监听器监听到这些事件，会触发一些行为。&ensp;&ensp;&ensp;&ensp;这就是监听器的简单解释，那么在SpringBoot中监听器是如何实现的呢？接下来我们就来看看吧！ 二、揭开面纱 深入肌理&ensp;&ensp;&ensp;&ensp;在SpringBoot中，系统监听器是 ApplicationListener，可以看到源码的注释，通过实现这个接口来实现监听器。ApplicationListener.java123456789101112131415161718192021222324252627282930313233343536package org.springframework.context;import java.util.EventListener;/** * Interface to be implemented by application event listeners. * * 通过实现这个接口来实现监听器 * 这个接口是按照监听器模式的标准来设计的 * &lt;p&gt;Based on the standard &#123;@code java.util.EventListener&#125; interface * for the Observer design pattern. * * 在Spring 3.0之后，一个应用监听器通常可以定义自己感兴趣的事件。当注册到Spring容器之后，当程序运行到一些关键节点时， * 会发出这些事件，并根据对应事件筛选出感兴趣的监听器进行触发。 * &lt;p&gt;As of Spring 3.0, an &#123;@code ApplicationListener&#125; can generically declare * the event type that it is interested in. When registered with a Spring * &#123;@code ApplicationContext&#125;, events will be filtered accordingly, with the * listener getting invoked for matching event objects only. * * @author Rod Johnson * @author Juergen Hoeller * @param &lt;E&gt; the specific &#123;@code ApplicationEvent&#125; subclass to listen to * @see org.springframework.context.ApplicationEvent * @see org.springframework.context.event.ApplicationEventMulticaster * @see org.springframework.context.event.EventListener */@FunctionalInterfacepublic interface ApplicationListener&lt;E extends ApplicationEvent&gt; extends EventListener &#123; /** * Handle an application event. * @param event the event to respond to */ void onApplicationEvent(E event);&#125;这个接口继承自 EventListener 接口，看源码可知 EventListener 接口就是一个接口定义，声明这是一个事件监听的接口EventListener.java12345678package java.util;/** * A tagging interface that all event listener interfaces must extend. * @since 1.1 */public interface EventListener &#123;&#125;&ensp;&ensp;&ensp;&ensp;上面的 ApplicationListener 接口还有一个泛型，继承自 ApplicationEvent，这就是说在实现这个接口的时候，可以声明自己感兴趣的事件。系统在触发这个系统监听器的时候会根据其感兴趣的事件做一个过滤。这个接口定义了一个 onApplicationEvent 方法，是当它监听到事件发生的时候，会去做什么事情。&ensp;&ensp;&ensp;&ensp;接下来我们看一下监听器模式的【广播器】在SpringBoot中的实现。&ensp;&ensp;&ensp;&ensp;系统广播器是 ApplicationEventMulticaster ，实现这个接口来管理一些应用监听器，并且广播事件。其中定义了添加、删除监听器的方法以及广播事件的方法。ApplicationEventMulticaster.java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465/** * 实现这个接口来管理一些应用监听器，并且广播事件 * Interface to be implemented by objects that can manage a number of * &#123;@link ApplicationListener&#125; objects and publish events to them. * * &lt;p&gt;An &#123;@link org.springframework.context.ApplicationEventPublisher&#125;, typically * a Spring &#123;@link org.springframework.context.ApplicationContext&#125;, can use an * &#123;@code ApplicationEventMulticaster&#125; as a delegate for actually publishing events. * * @author Rod Johnson * @author Juergen Hoeller * @author Stephane Nicoll * @see ApplicationListener */public interface ApplicationEventMulticaster &#123; /** * Add a listener to be notified of all events.添加监听器 * @param listener the listener to add */ void addApplicationListener(ApplicationListener&lt;?&gt; listener); /** * Add a listener bean to be notified of all events. * @param listenerBeanName the name of the listener bean to add */ void addApplicationListenerBean(String listenerBeanName); /** * Remove a listener from the notification list.删除监听器 * @param listener the listener to remove */ void removeApplicationListener(ApplicationListener&lt;?&gt; listener); /** * Remove a listener bean from the notification list. * @param listenerBeanName the name of the listener bean to remove */ void removeApplicationListenerBean(String listenerBeanName); /** * Remove all listeners registered with this multicaster.移除所有监听器 * &lt;p&gt;After a remove call, the multicaster will perform no action * on event notification until new listeners are registered. */ void removeAllListeners(); /** * Multicast the given application event to appropriate listeners.广播事件 * &lt;p&gt;Consider using &#123;@link #multicastEvent(ApplicationEvent, ResolvableType)&#125; * if possible as it provides better support for generics-based events. * @param event the event to multicast */ void multicastEvent(ApplicationEvent event); /** * Multicast the given application event to appropriate listeners. * &lt;p&gt;If the &#123;@code eventType&#125; is &#123;@code null&#125;, a default type is built * based on the &#123;@code event&#125; instance. * @param event the event to multicast * @param eventType the type of event (can be &#123;@code null&#125;) * @since 4.2 */ void multicastEvent(ApplicationEvent event, @Nullable ResolvableType eventType);&#125;&ensp;&ensp;&ensp;&ensp;系统事件在SpringBoot中的类图如下图所示。&ensp;&ensp;&ensp;&ensp;最顶层是 EventObject，它代表的是一个事件对象，接着 ApplicationEvent 继承它，代表这是一个应用事件，之后SpringApplicationEvent代表了这是 Spring 中的系统事件，ApplicationStartedEvent、ApplicationFailedEvent等都是 SpringApplicationEvent 的子类。&ensp;&ensp;&ensp;&ensp;上图提到了这么多的事件，那在 SpringBoot 中这些事件的发送顺序是怎样的呢？&ensp;&ensp;&ensp;&ensp;下面是SpringBoot启动过程中涉及的事件触发流程图：&ensp;&ensp;&ensp;&ensp;根据上述介绍的 SpringBoot 的事件相关的接口，我们可以自己定义一些监听器，然后注册到 SpringBoot 容器中。SpringBoot本身也有一些监听器的实现，上面我们已经提到，那么这些监听器是如何注册到 SpringBoot 容器中的呢？&ensp;&ensp;&ensp;&ensp;监听器注册的简明释义如下图所示，也是很容易理解的。&ensp;&ensp;&ensp;&ensp;具体代码是如何实现的呢？SpringApplication.java123456789101112131415161718192021222324/** * Create a new &#123;@link SpringApplication&#125; instance. The application context will load * beans from the specified primary sources (see &#123;@link SpringApplication class-level&#125; * documentation for details. The instance can be customized before calling * &#123;@link #run(String...)&#125;. * @param resourceLoader the resource loader to use * @param primarySources the primary bean sources * @see #run(Class, String[]) * @see #setSources(Set) */@SuppressWarnings(&#123; "unchecked", "rawtypes" &#125;)public SpringApplication(ResourceLoader resourceLoader, Class&lt;?&gt;... primarySources) &#123; this.resourceLoader = resourceLoader; Assert.notNull(primarySources, "PrimarySources must not be null"); this.primarySources = new LinkedHashSet&lt;&gt;(Arrays.asList(primarySources)); // 根据 classpath 判断 web 应用类型 this.webApplicationType = WebApplicationType.deduceFromClasspath(); // 初始化 initializers 属性 setInitializers((Collection) getSpringFactoriesInstances(ApplicationContextInitializer.class)); // 初始化 listeners 属性 setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class)); // 获得是调用了哪个 main 方法 this.mainApplicationClass = deduceMainApplicationClass();&#125;&ensp;&ensp;&ensp;&ensp;可以看到，在 SpringApplication 的构造方法中，调用 getSpringFactoriesInstances 方法获取 ApplicationListener 的实现，然后使用 setListener 方法设置监听器到 SpringBoot 容器中。Game.java123456789101112131415// 获得指定类对应的对象们private &lt;T&gt; Collection&lt;T&gt; getSpringFactoriesInstances(Class&lt;T&gt; type) &#123; return getSpringFactoriesInstances(type, new Class&lt;?&gt;[] &#123;&#125;);&#125;private &lt;T&gt; Collection&lt;T&gt; getSpringFactoriesInstances(Class&lt;T&gt; type, Class&lt;?&gt;[] parameterTypes,Object... args) &#123; ClassLoader classLoader = getClassLoader(); // Use names and ensure unique to protect against duplicates // 加载指定类型对应的，在 `META-INFO/spring.factories` 里的类名的数组 Set&lt;String&gt; names = new LinkedHashSet&lt;&gt;(SpringFactoriesLoader.loadFactoryNames(type, classLoader)); // 创建对象们 List&lt;T&gt; instances = createSpringFactoriesInstances(type, parameterTypes, classLoader, args, names); // 排序对象们 AnnotationAwareOrderComparator.sort(instances); return instances;&#125;&ensp;&ensp;&ensp;&ensp;先通过 spring.factory 获得实现的类名，然后依次实例化，之后进行排序，返回结果。我们来看一下 spring.factory 中监听器的描述。&ensp;&ensp;&ensp;&ensp;在 getSpringFactoriesInstances 方法中打断点，可以清楚地看到，通过 spring-factories 加载这些监听器的实现的类名&ensp;&ensp;&ensp;&ensp;监听器模式的4个要素，上面我们已经看了3个，还差一个事件触发机制，我们来看一下源码吧。&ensp;&ensp;&ensp;&ensp;上图圈中的部分，通过 SpringApplicationRunListener 数组 listeners 直接或进入方法触发事件。下面我们来具体看一下第一个 starting 事件。&ensp;&ensp;&ensp;&ensp;进入 starting 方法内部，可以看到它是遍历调用 SpringApplicationRunListener 的 starting方法。SpringApplicationRunListener.java12345void starting() &#123; for (SpringApplicationRunListener listener : this.listeners) &#123; listener.starting(); &#125;&#125;这个 SpringApplicationRunListener 中定义了各个阶段的事件，比如 starting、environmentPrepared、contextPrepared等等。SpringApplicationRunListener.java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576/** * Listener for the &#123;@link SpringApplication&#125; &#123;@code run&#125; method. * &#123;@link SpringApplicationRunListener&#125;s are loaded via the &#123;@link SpringFactoriesLoader&#125; * and should declare a public constructor that accepts a &#123;@link SpringApplication&#125; * instance and a &#123;@code String[]&#125; of arguments. A new * &#123;@link SpringApplicationRunListener&#125; instance will be created for each run. * * @author Phillip Webb * @author Dave Syer * @author Andy Wilkinson * @since 1.0.0 */public interface SpringApplicationRunListener &#123; /** * Called immediately when the run method has first started. Can be used for very * early initialization. */ default void starting() &#123; &#125; /** * Called once the environment has been prepared, but before the * &#123;@link ApplicationContext&#125; has been created. * @param environment the environment */ default void environmentPrepared(ConfigurableEnvironment environment) &#123; &#125; /** * Called once the &#123;@link ApplicationContext&#125; has been created and prepared, but * before sources have been loaded. * @param context the application context */ default void contextPrepared(ConfigurableApplicationContext context) &#123; &#125; /** * Called once the application context has been loaded but before it has been * refreshed. * @param context the application context */ default void contextLoaded(ConfigurableApplicationContext context) &#123; &#125; /** * The context has been refreshed and the application has started but * &#123;@link CommandLineRunner CommandLineRunners&#125; and &#123;@link ApplicationRunner * ApplicationRunners&#125; have not been called. * @param context the application context. * @since 2.0.0 */ default void started(ConfigurableApplicationContext context) &#123; &#125; /** * Called immediately before the run method finishes, when the application context has * been refreshed and all &#123;@link CommandLineRunner CommandLineRunners&#125; and * &#123;@link ApplicationRunner ApplicationRunners&#125; have been called. * @param context the application context. * @since 2.0.0 */ default void running(ConfigurableApplicationContext context) &#123; &#125; /** * Called when a failure occurs when running the application. * @param context the application context or &#123;@code null&#125; if a failure occurred before * the context was created * @param exception the failure * @since 2.0.0 */ default void failed(ConfigurableApplicationContext context, Throwable exception) &#123; &#125;&#125;&ensp;&ensp;&ensp;&ensp;因为这个类定义了 SpringBoot 启动过程中各个阶段的事件，所以只用调用这个类的不同方法就可以在相应的节点触发对应的事件。在 starting 方法内部，其实也很简单，就是调用了广播器的 multicastEvent 方法发送一个相应的 ApplicationStartingEvent 事件。&ensp;&ensp;&ensp;&ensp;SpringBoot容器通过这种机制，使监听器的内部实现与外部调用隔离开来。SpringBoot 容器在运行阶段，只需要调用这个类的各个关键方法就可以了，不需要 SpringBoot 容器自己去构造相应的事件来发送。&ensp;&ensp;&ensp;&ensp;我们进入广播器的 multicastEvent 方法内部。SimpleApplicationEventMulticaster.java1234567891011121314151617181920212223242526@Overridepublic void multicastEvent(ApplicationEvent event) &#123; multicastEvent(event, resolveDefaultEventType(event));&#125;@Overridepublic void multicastEvent(final ApplicationEvent event, @Nullable ResolvableType eventType) &#123; //对 eventType 做了一层包装 ResolvableType type = (eventType != null ? eventType : resolveDefaultEventType(event)); //获取线程池 Executor executor = getTaskExecutor(); //获取对当前事件感兴趣的监听器列表，然后遍历 for (ApplicationListener&lt;?&gt; listener : getApplicationListeners(event, type)) &#123; if (executor != null) &#123; executor.execute(() -&gt; invokeListener(listener, event)); &#125; else &#123; invokeListener(listener, event); &#125; &#125;&#125;private ResolvableType resolveDefaultEventType(ApplicationEvent event) &#123; return ResolvableType.forInstance(event);&#125;&ensp;&ensp;&ensp;&ensp;上述方法中 getApplicationListeners 方法是获取对当前事件感兴趣的监听器列表。我们看一下源码，是如何实现的。AbstractApplicationEventMulticaster.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/** * Return a Collection of ApplicationListeners matching the given * event type. Non-matching listeners get excluded early. * @param event the event to be propagated. Allows for excluding * non-matching listeners early, based on cached matching information. * @param eventType the event type * @return a Collection of ApplicationListeners * @see org.springframework.context.ApplicationListener */protected Collection&lt;ApplicationListener&lt;?&gt;&gt; getApplicationListeners( ApplicationEvent event, ResolvableType eventType) &#123; //首先先获取事件的源 source，也就是 SpringApplication Object source = event.getSource(); //获得source的class type Class&lt;?&gt; sourceType = (source != null ? source.getClass() : null); //通过sourceType和eventType构造一个缓存key。 //目的是若当前已经获得过对当前事件感兴趣的监听器列表，则从缓存中读取，不必再重新进行计算哪些监听器对该事件感兴趣，提升了效率 ListenerCacheKey cacheKey = new ListenerCacheKey(eventType, sourceType); // Quick check for existing entry on ConcurrentHashMap... ListenerRetriever retriever = this.retrieverCache.get(cacheKey); //第一次调用的话retriever为null if (retriever != null) &#123; return retriever.getApplicationListeners(); &#125; //beanClassLoader为null，进入if条件内 if (this.beanClassLoader == null || (ClassUtils.isCacheSafe(event.getClass(), this.beanClassLoader) &amp;&amp; (sourceType == null || ClassUtils.isCacheSafe(sourceType, this.beanClassLoader)))) &#123; // Fully synchronized building and caching of a ListenerRetriever //同步块 synchronized (this.retrievalMutex) &#123; //进入同步块，先从缓存中获取retriever retriever = this.retrieverCache.get(cacheKey); //缓存中retriever不为null，直接返回retriever的获取监听器方法 if (retriever != null) &#123; return retriever.getApplicationListeners(); &#125; //缓存retriever为null，创建ListenerRetriever实例 retriever = new ListenerRetriever(true); //调用retrieveApplicationListeners方法，检索监听器 Collection&lt;ApplicationListener&lt;?&gt;&gt; listeners = retrieveApplicationListeners(eventType, sourceType, retriever); //将检索到的retriever放进缓存中 this.retrieverCache.put(cacheKey, retriever); //返回监听器列表 return listeners; &#125; &#125; else &#123; // No ListenerRetriever caching -&gt; no synchronization necessary return retrieveApplicationListeners(eventType, sourceType, null); &#125;&#125;&ensp;&ensp;&ensp;&ensp;retrieveApplicationListeners 方法是如何检索监听器呢？我们继续来看。AbstractApplicationEventMulticaster.java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283/** * Actually retrieve the application listeners for the given event and source type. * @param eventType the event type * @param sourceType the event source type * @param retriever the ListenerRetriever, if supposed to populate one (for caching purposes) * @return the pre-filtered list of application listeners for the given event and source type */private Collection&lt;ApplicationListener&lt;?&gt;&gt; retrieveApplicationListeners( ResolvableType eventType, @Nullable Class&lt;?&gt; sourceType, @Nullable ListenerRetriever retriever) &#123; List&lt;ApplicationListener&lt;?&gt;&gt; allListeners = new ArrayList&lt;&gt;(); Set&lt;ApplicationListener&lt;?&gt;&gt; listeners; Set&lt;String&gt; listenerBeans; synchronized (this.retrievalMutex) &#123; //获得默认的applicationListeners和applicationLIstenerBeans //applicationListeners就是上文提到spring.factories加载进来的listener的实现 listeners = new LinkedHashSet&lt;&gt;(this.defaultRetriever.applicationListeners); listenerBeans = new LinkedHashSet&lt;&gt;(this.defaultRetriever.applicationListenerBeans); &#125; // Add programmatically registered listeners, including ones coming // from ApplicationListenerDetector (singleton beans and inner beans). //遍历监听器 for (ApplicationListener&lt;?&gt; listener : listeners) &#123; //依次判断，当前监听器是否对该事件感兴趣 if (supportsEvent(listener, eventType, sourceType)) &#123; //若感兴趣，会加入到集合中 if (retriever != null) &#123; retriever.applicationListeners.add(listener); &#125; allListeners.add(listener); &#125; &#125; // Add listeners by bean name, potentially overlapping with programmatically // registered listeners above - but here potentially with additional metadata. if (!listenerBeans.isEmpty()) &#123; ConfigurableBeanFactory beanFactory = getBeanFactory(); for (String listenerBeanName : listenerBeans) &#123; try &#123; if (supportsEvent(beanFactory, listenerBeanName, eventType)) &#123; ApplicationListener&lt;?&gt; listener = beanFactory.getBean(listenerBeanName, ApplicationListener.class); if (!allListeners.contains(listener) &amp;&amp; supportsEvent(listener, eventType, sourceType)) &#123; if (retriever != null) &#123; if (beanFactory.isSingleton(listenerBeanName)) &#123; retriever.applicationListeners.add(listener); &#125; else &#123; retriever.applicationListenerBeans.add(listenerBeanName); &#125; &#125; allListeners.add(listener); &#125; &#125; else &#123; // Remove non-matching listeners that originally came from // ApplicationListenerDetector, possibly ruled out by additional // BeanDefinition metadata (e.g. factory method generics) above. Object listener = beanFactory.getSingleton(listenerBeanName); if (retriever != null) &#123; retriever.applicationListeners.remove(listener); &#125; allListeners.remove(listener); &#125; &#125; catch (NoSuchBeanDefinitionException ex) &#123; // Singleton listener instance (without backing bean definition) disappeared - // probably in the middle of the destruction phase &#125; &#125; &#125; //对监听器通过order值进行排序 AnnotationAwareOrderComparator.sort(allListeners); if (retriever != null &amp;&amp; retriever.applicationListenerBeans.isEmpty()) &#123; retriever.applicationListeners.clear(); retriever.applicationListeners.addAll(allListeners); &#125; //将集合返回 return allListeners;&#125;&ensp;&ensp;&ensp;&ensp;上面方法中 supportsEvent 方法是如何判断是否感兴趣呢？我们来打断点看一下。&ensp;&ensp;&ensp;&ensp;首先进入的是 CloudFoundryVcapEnvironmentPostProcessor，该类不是 GenericApplicationListener 的子类，所以会为该类创建一个GenericApplicationListenerAdapter，作为smartListener。断点进入GenericApplicationListenerAdapter中，可以看到，delegate就是CloudFoundryVcapEnvironmentPostProcessor，接着会调用resolveDeclaredEventType方法，来计算当前代理类对哪个事件感兴趣。&ensp;&ensp;&ensp;&ensp;这个resolveDeclaredEventType方法，是spring内部实现的一个泛型解析器，会根据类定义获得该类声明的事件类型，由于CloudFoundryVcapEnvironmentPostProcessor类实现ApplicationListener，泛型是ApplicationPreparedEvent。&ensp;&ensp;&ensp;&ensp;所以该方法就会获得 ApplicationPreparedEvent。&ensp;&ensp;&ensp;&ensp;接着会调用 smartListener 的 supportsEventType 方法，判断是否支持该事件。进入方法，首先判断该类是否是 SmartApplicationListener 的子类，通过上面 CloudFoundryVcapEnvironmentPostProcessor 的定义，它不是 SmartApplicationListener 的子类，所以会进入 else 中。&ensp;&ensp;&ensp;&ensp;上面得到 declaredEventType 是 ApplicationPreparedEvent ，所以不为null。当前 eventType 是 ApplicationStartingEvent，显然“||”后半部分结果也是false，所以 smartListener.supportsEventType 是false，因为supportsEvent方法后面条件是“&amp;&amp;”，所以后面的内容不必在意，可以直接确定该监听器不支持该事件。&ensp;&ensp;&ensp;&ensp;我们接着调试，接下来进入的是 ConfigFileApplicationListener，按照上述同样的方法进行计算，由于它是 SmartApplicationListener 的子类。&ensp;&ensp;&ensp;&ensp;所以会进入 if 条件内&ensp;&ensp;&ensp;&ensp;这里会调用实现类的 supportEvent 方法，即 ConfigFileApplicationListener 类的 supportsEventType 方法。&ensp;&ensp;&ensp;&ensp;判断当前这个event是否是 ApplicationEnvironmentPreparedEvent，或者是否是 ApplicationPreparedEvent，都不是的话，会返回false，也就是说对该事件不感兴趣，所以不会将 ConfigFileApplicationListener 添加到上述的感兴趣监听器列表中。&ensp;&ensp;&ensp;&ensp;通过以上的方法，就检索出了哪些监听器对当前事件感兴趣。&ensp;&ensp;&ensp;&ensp;之后在遍历这些监听器的过程中，会调用 invokeListener 方法&ensp;&ensp;&ensp;&ensp;invokeListener方法中会调用doInvokeListener方法，最终我们可以看到listener.onApplicationEvent，这里会进入具体事件的触发&ensp;&ensp;&ensp;&ensp;以 ConfigFileApplicationListener 为例，会根据不同的event触发不同的事件。&ensp;&ensp;&ensp;&ensp;通过上面的分析，总结一下获取监听器列表逻辑，如下图所示。&ensp;&ensp;&ensp;&ensp;其中supportsEvent流程如下图所示。 三、总结&ensp;&ensp;&ensp;&ensp;以上关于SpringBoot中监听器的主要核心方法的实现我们已经一点点看过了，看上去很复杂，但是实际上还是按照标准的监听器模式实现的。其中将一系列事件的触发方法封装在一个runListener中，降低了系统的耦合度，使得调用的时候也变得很轻松，这一点很值得我们学习。]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基础加固-建造者模式]]></title>
    <url>%2F2019%2F07%2F09%2F%E5%9F%BA%E7%A1%80%E5%8A%A0%E5%9B%BA-%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[&ensp;&ensp;&ensp;上篇我们复习了工厂模式，这节我们来看一下创建型设计模式的另一种模式–建造者模式。 一.定义&ensp;&ensp;&ensp;建造者模式是指将一个复杂对象的构建和它的表示分离，使同样的构建过程可以构建不同的表示。用户只需要指定需要建造的类型就可以得到它们，建造过程以及细节并不需要知道。适用于那些创建流程固定，但顺序不一定固定的对象。如果一个对象有非常复杂的内部结构，即有很多属性，我们想把这种复杂对象的创建和使用进行分离，我们可以使用建造者模式。这样看定义难免抽象，接下来我们一起编写代码来加深对工厂模式的理解。 二、标准版1.代码实现&ensp;&ensp;&ensp;首先我们有一个类Game，有名称、简介、制作团队、宣传视频、社区几个属性。代码如下：Game.java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public class Game &#123; private String name; private String introduce; private String team; private String video; private String community; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getIntroduce() &#123; return introduce; &#125; public void setIntroduce(String introduce) &#123; this.introduce = introduce; &#125; public String getTeam() &#123; return team; &#125; public void setTeam(String team) &#123; this.team = team; &#125; public String getVideo() &#123; return video; &#125; public void setVideo(String video) &#123; this.video = video; &#125; public String getCommunity() &#123; return community; &#125; public void setCommunity(String community) &#123; this.community = community; &#125; @Override public String toString() &#123; return "Game&#123;" + "name='" + name + '\'' + ", introduce='" + introduce + '\'' + ", team='" + team + '\'' + ", video='" + video + '\'' + ", community='" + community + '\'' + '&#125;'; &#125;&#125; 我们创建一个抽象类GameBuilder，其中定义了创建各个属性的方法和生成Game对象的方法，代码如下：GameBuilder.java12345678910111213public abstract class GameBuilder &#123; public abstract void buildName(String name); public abstract void buildIntroduce(String introduce); public abstract void buildTeam(String team); public abstract void buildVideo(String video); public abstract void buildCommunity(String community); public abstract Game makeGame();&#125; 接下来我们要创建具体的builder实现，比如我们要创建一个动作游戏的建造者ActionGameBuilder，我们只需要继承上面的抽象builder，重写里面的方法即可，代码如下：ActionGameBuilder.java123456789101112131415161718192021222324252627282930313233public class ActionGameBuilder extends GameBuilder &#123; Game game = new Game(); @Override public void buildName(String name) &#123; game.setName(name); &#125; @Override public void buildIntroduce(String introduce) &#123; game.setIntroduce(introduce); &#125; @Override public void buildTeam(String team) &#123; game.setTeam(team); &#125; @Override public void buildVideo(String video) &#123; game.setVideo(video); &#125; @Override public void buildCommunity(String community) &#123; game.setCommunity(community); &#125; @Override public Game makeGame() &#123; return game; &#125;&#125; 其实现在我们已经可以使用我们创建的builder进行创建游戏了，不过这里可以定义一个管理角色的对象，对builder进行管理，用它来进行管理对象的创建，这里我们定义一个游戏经理类GameManager。GameManager.java1234567891011121314151617public class GameManager &#123; private GameBuilder gameBuilder; public void setGameBuilder(GameBuilder gameBuilder) &#123; this.gameBuilder = gameBuilder; &#125; public Game makeGame(String name, String introduce, String team, String video, String community) &#123; gameBuilder.buildName(name); gameBuilder.buildIntroduce(introduce); gameBuilder.buildTeam(team); gameBuilder.buildVideo(video); gameBuilder.buildCommunity(community); return gameBuilder.makeGame(); &#125;&#125;写到这里我们已经完成了一个标准的建造者模式代码，写一个测试类来测试一下。Test.java123456789101112131415public class Test &#123; public static void main(String[] args) &#123; GameBuilder gameBuilder = new ActionGameBuilder(); GameManager manager = new GameManager(); manager.setGameBuilder(gameBuilder); Game game = manager.makeGame("游戏名称", "这是一个很好玩的动作游戏", "制作团队", "游戏宣传视频", "游戏社区"); System.out.println(game); &#125;&#125;控制台可以看到创建的游戏信息。123Game&#123;name=&apos;游戏名称&apos;, introduce=&apos;这是一个很好玩的动作游戏&apos;, team=&apos;制作团队&apos;, video=&apos;游戏宣传视频&apos;, community=&apos;游戏社区&apos;&#125;Process finished with exit code 0 2.UML&ensp;&ensp;&ensp;我们可以看到标准的建造者模式的UML类图。我们测试时通过游戏经理和动作游戏建造者创建了含有较多属性的游戏类，并不关心创建的过程和顺序，有很好的封装性，使创建和使用分离，并且有很好的扩展性，建造类之间独立，在一定程度上解耦。 三、演进版1.代码实现&ensp;&ensp;&ensp;更多时候我们需要一种可以链式调用的形式进行建造我们的对象，实现其实也很简单，我们可以创建一个静态内部类作为对象的builder，具体代码如下：Game.java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364public class Game &#123; private String name; private String introduce; private String team; private String video; private String community; public Game(GameBuilder gameBuilder) &#123; this.name = gameBuilder.name; this.introduce = gameBuilder.introduce; this.team = gameBuilder.team; this.video = gameBuilder.video; this.community = gameBuilder.community; &#125; @Override public String toString() &#123; return "Game&#123;" + "name='" + name + '\'' + ", introduce='" + introduce + '\'' + ", team='" + team + '\'' + ", video='" + video + '\'' + ", community='" + community + '\'' + '&#125;'; &#125; public static class GameBuilder &#123; private String name; private String introduce; private String team; private String video; private String community; public GameBuilder buildName(String name) &#123; this.name = name; return this; &#125; public GameBuilder buildIntroduce(String introduce) &#123; this.introduce = introduce; return this; &#125; public GameBuilder buildTeam(String team) &#123; this.team = team; return this; &#125; public GameBuilder buildVideo(String video) &#123; this.video = video; return this; &#125; public GameBuilder buildCommunity(String community) &#123; this.community = community; return this; &#125; public Game build() &#123; return new Game(this); &#125; &#125;&#125;&ensp;&ensp;&ensp;跟标准版本不同的是，在builder中的buildXxx方法返回的是builder本身，这样我们就可以使用链式调用的方式进行创建，最后调用build方法返回我们的实体类。写一个测试类测试一下。Test.java1234567891011public class Test &#123; public static void main(String[] args) &#123; Game game = new Game.GameBuilder().buildName("游戏名称") .buildIntroduce("这是一个很好玩的游戏") .buildTeam("制作团队") .buildVideo("介绍视频") .buildCommunity("游戏社区") .build(); System.out.println(game); &#125;&#125;执行程序，可以看到我们创建的game的信息。123Game&#123;name=&apos;游戏名称&apos;, introduce=&apos;这是一个很好玩的游戏&apos;, team=&apos;制作团队&apos;, video=&apos;介绍视频&apos;, community=&apos;游戏社区&apos;&#125;Process finished with exit code 0 2.UML&ensp;&ensp;&ensp;演进版本的UML类图更加简单，可以很清楚地看到，对于应用方，只需要使用对象的builder进行链式调用，最后调用build方法返回所需的对象实例即可。 四、总结&ensp;&ensp;&ensp;以上介绍了两个版本的建造者模式的实现，总体来说都是比较简单，容易理解的。在日常应用中，第二种是比较常用的，各种开源框架也都广泛使用，比如Guava中CacheBuilder，都是通过第二种链式调用的方式创建对象，使用方便。对于以后的扩展维护也比较方便。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>基础</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基础加固-工厂模式]]></title>
    <url>%2F2019%2F06%2F27%2F%E5%9F%BA%E7%A1%80%E5%8A%A0%E5%9B%BA-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[&ensp;&ensp;&ensp;随着工作年限的增加，对工作中的代码结构和质量的追求也在增加。之前看书学习过的设计模式，当时也就是看看，看过或许有的忘记，或许不会使用。入职新公司以来，看团队高级工程师的代码，为了实现一个需求，可以使用合适的设计模式去规范代码，使代码的可读性和可扩展性都大大提升，我意识到是时候巩固一下基础，系统学习一下设计模式了。从这边文章开始，我将从创建型模式中的工厂模式开始复习，实现简单的demo，对比各个模式的UML类图，希望提升自己的编码能力，同时也便于阅读各种开源框架的源码。闲话少许，我们开始吧~ 一、简单工厂模式1.问题引入&ensp;&ensp;&ensp;首先来看一个场景，我有一个抽象类Game，标识这个类为一个游戏，游戏可以有很多种，比如“马里奥”、“塞尔达”等等。创建一个具体的游戏，一种最简单的方式就是创建一个具体游戏类继承Game抽象类，然后重写里面的建造方法。代码如下：Game.java123public abstract class Game &#123; public abstract void produce();&#125; Mario游戏MarioGame.java123456public class MarioGame extends Game&#123; @Override public void produce() &#123; System.out.println("Mario game produced!"); &#125;&#125; Zelda游戏ZeldaGame.java123456public class ZeldaGame extends Game &#123; @Override public void produce() &#123; System.out.println("Zelda game produced!"); &#125;&#125;这样我们在需要创建某种游戏的时候，直接new对应的具体游戏类,调用其中的建造方法即可。ZeldaGame.java123456public class Test &#123; public static void main(String[] args) &#123; Game game = new MarioGame(); game.produce(); &#125;&#125;可以看到控制台中打印的结果，创建了Mario游戏123Mario game produced!Process finished with exit code 0&ensp;&ensp;&ensp;看到这里，大家肯定已经发现了这种写法的弊端。每次需要直接new出来想要的具体游戏类，我们如果能使用一个工具去创建我们想要的具体游戏类，不需要关心创建的过程，那岂不是很爽吗？这时候简单工厂模式就登场了。 2.代码实现&ensp;&ensp;&ensp;和上面一样，还是有我们的抽象游戏Game类，不同的游戏去继承Game类，实现自己的produce方法。不同的是，这次我们创建一个简单工厂类GameFactory，根据参数通过这个工厂去创建我们需要的具体游戏类。具体代码如下：GameFactory.java1234567891011public class GameFactory &#123; public Game getGame(String type)&#123; if ("mario".equalsIgnoreCase(type))&#123; return new MarioGame(); &#125;else if ("zelda".equalsIgnoreCase(type))&#123; return new ZeldaGame(); &#125;else &#123; return null; &#125; &#125;&#125;这样，我们在使用工厂类创建具体游戏类的时候就不用直接new出来具体的游戏，直接使用工厂类就可以了。GameFactory.java12345678910public class Test &#123; public static void main(String[] args) &#123; GameFactory gameFactory = new GameFactory(); Game game = gameFactory.getGame("zelda"); if (game == null)&#123; return; &#125; game.produce(); &#125;&#125;结果如下，我们成功创建了zelda游戏123Zelda game produced!Process finished with exit code 0 3.UML我们先看一下未引入简单工厂时候的UML类图。&ensp;&ensp;&ensp;可以看到我们创建Mario和Zelda两个游戏，都分别通过具体的类进行创建，以后如果要创建更多的游戏，那时的UML大家应该可以想象，从应用方向不同的具体游戏类都会有create联系，整个关系就非常杂乱。我们使用了简单工厂模式之后的UML是什么样的呢？ &ensp;&ensp;&ensp;这样应用方使用简单工厂创建不同的游戏时，只需要告诉工厂我需要什么游戏即可，就不必关心我应该具体new什么游戏了。&ensp;&ensp;&ensp;当然这里实现的简单工厂是最简单的形式，其实完全可以在工厂类中使用java反射创建不同的游戏，在应用方使用的时候，传入对应的Class即可 二、工厂方法模式1.问题引入&ensp;&ensp;&ensp;通过上面简单工厂模式，我们已经可以通过工厂来创建具体的对象。但是这时候我需要增加一个新的“精灵宝可梦”的游戏，我们怎么操作呢？也很简单，新建一个Pokemon游戏的类继承Game，实现自己的produce方法，在工厂类中修改逻辑，使工厂可以创建新的游戏。你可能会说，这样也很好啊，创建新游戏的时候我只需要去改工厂里的逻辑就好了，但是当类越来越多，逻辑越来越复杂，你的工厂类就会变得特别庞大，每次创建新的游戏都要修改这个工厂类，是不符合软件设计中的开闭原则的。这时候，如果按不同游戏的类型把工厂分为不同的工厂，创建的时候只需要使用对应的工厂生产我们需要的游戏就好了。 2.代码实现&ensp;&ensp;&ensp;首先我们新创建“精灵宝可梦”游戏类，同样让它继承Game。PokemonGame.java123456public class PokemonGame extends Game &#123; @Override public void produce() &#123; System.out.println("Pokemon game produced!"); &#125;&#125;刚刚说到，要按不同游戏的类型创建不同的工厂，这里我们首先把工厂抽象出来，建一个抽象工厂类GameFactory.java123public abstract class GameFactory &#123; public abstract Game getGame();&#125;之后，通过继承这个抽象工厂类，创建“马里奥”、“塞尔达”、“精灵宝可梦”的工厂MarioGameFactory.java123456public class MarioGameFactory extends GameFactory &#123; @Override public Game getGame() &#123; return new MarioGame(); &#125;&#125;ZeldaGameFactory.java123456public class ZeldaGameFactory extends GameFactory &#123; @Override public Game getGame() &#123; return new ZeldaGame(); &#125;&#125;PokemonGameFactory.java123456public class PokemonGameFactory extends GameFactory &#123; @Override public Game getGame() &#123; return new PokemonGame(); &#125;&#125;这些不同的工厂创建后，我们就可以使用各自的工厂来生产各自的游戏了，这里以生产Pokemon游戏为例Test.java1234567public class Test &#123; public static void main(String[] args) &#123; GameFactory gameFactory = new PokemonGameFactory(); Game game = gameFactory.getGame(); game.produce(); &#125;&#125;执行代码，控制台输出如下：123Pokemon game produced!Process finished with exit code 0我们已经成功将简单工厂升级成了工厂方法模式，提高了代码的可复用性。 3.UML这时候的UML类图如下: 三、抽象工厂模式1.问题引入&ensp;&ensp;&ensp;假如每个游戏都有一个游戏社区，比如Mario有游戏还有游戏社区，Pokemon也有游戏和游戏社区，这里Mario的游戏和社区属于同一个产品族，Pokemon的游戏和社区也属于同一个产品族；而Mario的游戏社区和Pokemon的游戏社区属于同一产品等级，Mario游戏和Pokemon游戏属于同一产品等级。有类似于这种关系的场景，我们使用一种怎样的模式呢？ 2.代码实现&ensp;&ensp;&ensp;首先我们创建一个接口，抽象出来一个工厂GameFactory，这个抽象工厂定义了可以获取游戏和游戏社区的方法。GameFactory.java12345public interface GameFactory &#123; Game getGame(); Community getCommunity();&#125;其中Game和Community是抽象类，具体的游戏和社区需要继承这两个抽象类自己去实现。Game.java123public abstract class Game &#123; public abstract void produce();&#125;Community.java123public abstract class Community &#123; public abstract void produce();&#125;MarioGame.java123456public class MarioGame extends Game &#123; @Override public void produce() &#123; System.out.println("Mario game produced!"); &#125;&#125;MarioCommunity.java123456public class MarioCommunity extends Community &#123; @Override public void produce() &#123; System.out.println("Mario community produced."); &#125;&#125;之后定义不同的具体工厂，实现GameFactory接口，实现接口中的获取游戏和游戏社区的方法。这里的游戏和社区属于同一产品族，使用具体的工厂可以获得同一产品族的对象。Mario产品族的工厂MarioFactory.java1234567891011public class MarioFactory implements GameFactory &#123; @Override public Game getGame() &#123; return new MarioGame(); &#125; @Override public Community getCommunity() &#123; return new MarioCommunity(); &#125;&#125;Pokemon产品族的工厂PokemonFactory.java1234567891011public class PokemonFactory implements GameFactory &#123; @Override public Game getGame() &#123; return new PokemonGame(); &#125; @Override public Community getCommunity() &#123; return new PokemonCommunity(); &#125;&#125;我们写一个测试类测试一下。Test.java123456789101112public class Test &#123; public static void main(String[] args) &#123; //创建抽象工厂，指定是Mario工厂 GameFactory gameFactory = new MarioFactory(); //调用抽象工厂的方法获取游戏和游戏社区 Game game = gameFactory.getGame(); Community community = gameFactory.getCommunity(); //会根据具体工厂的不同获得不同的游戏和游戏社区，这里是Mario产品族 game.produce(); community.produce(); &#125;&#125; 3.UML我们来看一下现在的UML类图。&ensp;&ensp;&ensp;关系很清晰，大家都可以理解。现在想一个问题，如果我们的业务场景需要经常增加产品族内的产品，那么我们总是需要增加抽象工厂里的方法，进而修改抽象工厂的实现，这么一来就不符合软件设计的开闭原则了；如果我们的业务场景需要经常增加产品等级，这时候我们仅需要添加相应的产品工厂和产品类即可。 &ensp;&ensp;&ensp;以上介绍了三种工厂相关的模式，不能说哪种模式更优于哪种，只能根据具体的业务场景，选择合适的模式。没有最好的设计模式，只有最适合的设计模式。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>基础</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记一次大批量物理删除数据]]></title>
    <url>%2F2019%2F04%2F29%2F%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%A4%A7%E6%89%B9%E9%87%8F%E7%89%A9%E7%90%86%E5%88%A0%E9%99%A4%E6%95%B0%E6%8D%AE%2F</url>
    <content type="text"><![CDATA[&ensp;&ensp;&ensp;接上次闹钟项目更改字符集之后，这几天又需要对线上数据做处理。背景是，同步闹钟的时候会把用户之前删除过的闹钟都同步下来，而删除的闹钟在客户端没有任何显示，也没有任何恢复的操作，对于用户来说其实是完全没有用的数据。当用户的无用历史闹钟增多到一定数量，同步的时候，客户端上报的数据body就特别大，已经超过了Nginx配置的request最大限制，这样就导致了部分老用户无法同步的情况。解决思路其实很简单，将客户端的上报策略修改成分批上传，服务端分批的返回，最后的结果客户端在本地做聚合，显示给用户。但是这需要客户端和服务端共同修改，客户端还要发版审核，现在需要一种比较快速的方式，让用户在尽可能短的时间内可以进行同步。最后决定将数据库中2018年以前用户无用的闹钟进行删除，找到dba同学商量要删除数据，但是很不幸，dba同学告知我们目前他们没有成熟的工具操作，让我们自己写程序删除，他们可以负责备份数据。看来只能靠自己了，接下来就看一下从分析到实现整个删除任务的具体过程。 一、思路分析&ensp;&ensp;&ensp;需要进行删除的这张表是一个很宽的数据量很大的表，当前共有七千多万条数据，经过筛选查询，发现2018年之前且状态为无效的闹钟数量达到了五千多万，也就是说现在需求是要物理删除这五千多万条数据。需求明确了，下面就要考虑几个问题。 要删除的五千多万条数据如何定位？ 怎样高效地删除这么大量的数据同时保证负载正常？ 怎样保证集群环境下，删除任务只执行一次？ 我们分别看一下解决这些问题的思路。 1.定位目标数据&ensp;&ensp;&ensp;表中主要字段包括user_id,status,init_time,分别表示闹钟所属的用户id、闹钟状态、闹钟初始化时间。删除的大体思路是通过in user_id字段来delete，那么如何找到要in哪些user_id呢？从上面的分析可以知道，这张表拥有很大的数据量，想要一次delete是不可能的事情，需要进行分批删除，每次in一部分user_id。那么每次的user_id如何获取呢？可以通过分页排序的group by语句得到分批的user_id。 1select user_id from clocks order by user_id group by user_id limit 0,500; &ensp;&ensp;&ensp;上面的分页查询看上去没什么问题，但是随着翻页次数增大，效率也越来越慢，假设我们翻到了2000页，这个语句查询的2000之前的数据都是无用的，效率特别低下。由数据量分析可知，这张表里通过user_id分组，可以得到200W+数据，如果我们每次分页查询500条，计算可得 最后我们需要将 200W / 500 作为limit的起点，这样的查询是灾难性的。但是通过下面的sql修改，可以大大提高分页的查询效率。 1234select user_id from clocks where user_id &gt; 0 order by user_id group by user_id limit 500;select user_id from clocks where user_id &gt; 500 order by user_id group by user_id limit 500;select user_id from clocks where user_id &gt; 1000 order by user_id group by user_id limit 500;... &ensp;&ensp;&ensp;通过where过滤当前页之前的数据，可以大大提高查询效率。只需要每次记下当次分页结果中最大的user_id，下次分页将此user_id作为分页起始条件进行过滤即可。因为我们使用order by进行排序，查询结果都是有序的，可以将每次的user_id结果放进一个LinkedList中，每次使用的时候peekLast()就能得到当前分组的最大user_id。定位目标数据的思路大体就是这样，思路清晰后代码实现也是很容易的。 ClockDeleteUser.java12345678910111213141516@Datapublic class ClockDeleteUser &#123; // 下一次分页的起始user_id private long nextFirstUserId; private LinkedList&lt;Long&gt; userIds; private int perLimit; public ClockDeleteUser(long nextFirstUserId,int perLimit)&#123; this.nextFirstUserId = nextFirstUserId; this.perLimit = perLimit; &#125;&#125; ClockDeleteService.java123456789101112131415161718192021222324252627282930313233343536@Servicepublic class ClockDeleteService &#123; private final static int DELETE_USER_PER_LIMIT = 500; @Autowired private SyncDao syncDao; /** * 获取删除语句中in的userId的信息集合 * @return */ public List&lt;List&lt;Long&gt;&gt; getDeleteUser()&#123; List&lt;List&lt;Long&gt;&gt; result = new ArrayList&lt;&gt;(); long nextFirstUserId = 0; ClockDeleteUser clockDeleteUser = new ClockDeleteUser(nextFirstUserId,DELETE_USER_PER_LIMIT); LinkedList&lt;Long&gt; userIds = syncDao.getClockDeleteUserIds(clockDeleteUser); while (CollectionUtils.isNotEmpty(userIds))&#123; result.add(userIds); clockDeleteUser.setNextFirstUserId(userIds.peekLast()); userIds = syncDao.getClockDeleteUserIds(clockDeleteUser); &#125; return result; &#125; /** * 按照userId集合删除无用的闹钟 * @param userIds * @return */ public boolean deleteUnusedClock(List&lt;Long&gt; userIds)&#123; // 分批删除无用闹钟 return syncDao.deleteUnusedClocksByUserInitTime(userIds); &#125;&#125; 2.多线程删除&ensp;&ensp;&ensp;找到了每次分批的user_id条件，接下来就可以进行删除操作了。这么庞大的数据量，每次串行执行delete where，明显效率很低，估计删除完这些数据也要进行几个小时吧。这时我们很容易地想到了使用多个线程同时进行delete操作。因为user_id字段是这张表的索引，所以delete的时候走索引，并不会锁住整个表，所以我们可以使用多个线程同时进行删除。但是由于数据量大，分组要达4000+，我们要使用多少个线程同时工作呢？这里我们通过 Runtime.getRuntime().availableProcessors() 获取当前可用处理器数量，用来创建线程池。&ensp;&ensp;&ensp;我们使用 Executors.newFixedThreadPool() 创建固定线程数的线程池，传入的参数就是上面获取的处理器的数量。当工作线程到达了处理器数量，新进来的任务便会进入阻塞队列等待，待工作线程中有任务完成，阻塞队列中的任务再执行。线程池的工作原理，大家应该都已经很熟悉了，在此就不多说了。多线程执行当然能提高效率，但是我们能将这4000+的任务一下子提交给线程池来执行吗？这样的话cpu会有突然增长，这里我们可以使用限流策略，控制任务进入线程池的速度。Google Guava中提供了一个很好用的限流工具，它就是 RateLimiter，一个基于令牌桶算法实现的限流器，想必大家也都知道。使用RateLimiter可以很方便地实现限流。&ensp;&ensp;&ensp;通过以上的思考，多线程删除也可以很简单地实现，在文章的后面我会给出实现代码。 3.集群中单点执行任务&ensp;&ensp;&ensp;应用部署在集群中，但是我们需求的任务只需要一台机器执行即可。我们如何来保证集群中只有一台机器执行这个删除任务呢？&ensp;&ensp;&ensp;我们可以使用Redis来实现。大体思路如下：&ensp;&ensp;&ensp;判断标识删除任务执行的Key是否存在，存在的话直接返回，不存在则使用 SETNX 尝试设置Key的value为当前自己的Pid，再次获取key对应的value值，若value和自己当前的pid不同，说明不是当前节点获取的锁，不能执行任务，只有value和当前自己的pid相同时才执行删除任务。这样就可以保证集群中只有一个节点执行了删除任务，在任务执行结束之后要删除key。下面给出流程图，思路一目了然。 4.在哪里触发任务&ensp;&ensp;&ensp;分析了如何定位以及删除数据，那我们如何触发任务的执行呢？这里我在配置文件中设置了一个开关，用来标识本次启动是否需要执行删除任务。这个开关和上面提到的redis key共同决定是否在当前节点执行任务。&ensp;&ensp;&ensp;什么时机进行删除呢？因为删除任务中使用了spring bean service，所以应该在spring容器初始化bean完成后执行删除任务。&ensp;&ensp;&ensp;可以通过实现 ApplicationRunner 接口，实现接口的run方法来执行我们的任务。查阅springboot官方文档@SpringbootDocdocs.spring.io/spring-boot/docs/2.1.4.RELEASE/reference/htmlsingle/#using-boot 二、代码实现&ensp;&ensp;&ensp;通过以上分析，实现思路已经非常清晰，下面给出实现代码，仅供参考。DeleteClockTask.java1234567891011121314151617181920212223@Slf4j@Datapublic class DeleteClockTask implements Runnable &#123; private String name; private List&lt;Long&gt; userIds; private ClockDeleteService clockDeleteService; public DeleteClockTask(String name, List&lt;Long&gt; userIds) &#123; this.name = name; this.userIds = userIds; this.clockDeleteService = (ClockDeleteService) SpringContextUtils.getBeanByClass(ClockDeleteService.class); &#125; @Override public void run() &#123; log.info("delete clock task &#123;&#125; start...", name); clockDeleteService.deleteUnusedClock(userIds); log.info("delete unused clock task &#123;&#125; end.", name); &#125;&#125; InitialBeanHandler.java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465@Component@Slf4jpublic class InitialBeanHandler implements ApplicationRunner &#123; @Autowired private ClockDeleteService clockDeleteService; @Value("$&#123;task.delete.status&#125;") private int deleteSwitch; @Autowired private RedissonHandler redissonHandler; private final static long TASK_EXPIRE_MILLS_TIME = 60 * 60 * 1000; private final static String DELETE_CLOCK_TASK_KEY = "delete_used_clock_running"; private final static ExecutorService pool = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors()); @Override public void run(ApplicationArguments args) throws Exception &#123; // 先判断删除开关是否开启 log.info("删除无用闹钟开关 deleteSwitch : " + deleteSwitch); // 若开关开启，并且当前没有节点在执行删除任务，则执行删除任务 //通过redis查询是否有节点已经运行了删除任务 boolean taskRunning = redissonHandler.exists(DELETE_CLOCK_TASK_KEY); List&lt;DeleteClockTask&gt; tasks = new ArrayList&lt;&gt;(); if (deleteSwitch == 1 &amp;&amp; !taskRunning) &#123; //当前节点执行删除任务，设置redis中的任务状态 String nowPid = ManagementFactory.getRuntimeMXBean().getName(); redissonHandler.setNX(DELETE_CLOCK_TASK_KEY, nowPid, TASK_EXPIRE_MILLS_TIME); String taskRunningPid = redissonHandler.get(DELETE_CLOCK_TASK_KEY, String.class); if (!StringUtils.equals(taskRunningPid, nowPid)) &#123; return; &#125; //获取分批删除的userId的list List&lt;List&lt;Long&gt;&gt; deleteUsersList = clockDeleteService.getDeleteUser(); if (CollectionUtils.isNotEmpty(deleteUsersList)) &#123; int size = deleteUsersList.size(); log.info("There are &#123;&#125; delete clock tasks totally.", size); for (int i = 0; i &lt; size; i++) &#123; List&lt;Long&gt; userIds = deleteUsersList.get(i); DeleteClockTask task = new DeleteClockTask("deleteTask" + i, userIds); tasks.add(task); &#125; &#125; //限流 RateLimiter rateLimiter = RateLimiter.create(2); for (DeleteClockTask task : tasks) &#123; log.info("delete clock task &#123;&#125; wait time &#123;&#125;", task.getName(), rateLimiter.acquire()); pool.execute(task); log.info("delete clock task &#123;&#125; finished.", task.getName()); &#125; log.info("delete clock tasks all finished"); //执行完成，将redis中标志任务执行状态的key删除 redissonHandler.del(DELETE_CLOCK_TASK_KEY); &#125; &#125;&#125; 三、线上执行&ensp;&ensp;&ensp;经过测试环境反复测试，最终挑了个风和日丽的日子，准备在生产环境执行。&ensp;&ensp;&ensp;合并master，开始部署，盯着日志，静静等待…&ensp;&ensp;&ensp;线上删除任务共分为了4014个组，按每秒钟2组的速度进入线程池,开始执行删除任务，观察cpu使用率，基本稳定，没有出现激增。半个多小时后，所有任务执行完成。一共删除了58115102条数据，至此这次删除历史数据的任务完成。&ensp;&ensp;&ensp;第一次在线上物理删除这么大量的数据，仅此记录一下本次处理的思路和实现方法。]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>线上</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记一次数据库更改字符集踩的坑]]></title>
    <url>%2F2019%2F04%2F19%2F%E8%AE%B0%E4%B8%80%E6%AC%A1%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9B%B4%E6%94%B9%E5%AD%97%E7%AC%A6%E9%9B%86%E8%B8%A9%E7%9A%84%E5%9D%91%2F</url>
    <content type="text"><![CDATA[最近接手了一个闹钟App的后端项目，其中有个功能就是用户可以将本地闹钟同步到服务器，以便更换设备后能从服务器同步数据到新设备。但是这几天观察后台日志发现，同步的时候总是ERROR，定位错误发现跟数据库的字符集有关，在此记录一下本次线上错误的排查过程。 一、定位ERROR通过Kibana查看最近的ERROR日志，可发现如下的错误描述。&ensp;&ensp;&ensp;很明显可以发现，是因为insert的时候插入的数据不符合该列的要求。进而查看插入的数据，定位到插入内容含有特殊字符，比如emoji表情和其他一些字符。查询table的字符集发现这张表是utf8字符集，并不是utf8mb4的字符集，所以报这个错也是很正常了。看到这里你可能会问，这个问题应该在很久之前就应该发现了，为什么这几天才把它揪出来呢？这个项目很早了，包括后端和客户端，经过客户端同学的代码筛查，发现由于历史的原因，客户端对同步的结果的处理存在bug，导致后台同步失败某冲情况下也会提示同步成功，所以前台并不会暴露这个问题。&ensp;&ensp;&ensp;所以当时建表使用的utf8字符集已经不能满足用户的自定义名称的需求，需要变更这张表的字符集为utf8mb4。但是一查数据，这张表就有七千多万的数据，更改字符集的话对之前的内容是否有影响，要执行多久？问题找到了，就开始找dba同学商量，最后决定先创建一张utf8mb4的新表，将原来的数据导入到新表，完成后，再将原表rename成新表，完成切换。说干就干，晚上提了工单，dba开始执行。 二、黎明前的黑暗&ensp;&ensp;&ensp;第二天早上起床，发现接到了n多条服务报警，正是昨天更改字符集的服务。到了公司立马查看服务日志，发现服务挂了，重新部署启动，没有两分钟又挂了。这是什么原因呢？没有更改任何代码，只更改了一个表的字符集，整个服务就崩了吗？这是什么道理，一时间也是很懵。这时候dba那边发来了一长串slow sql，是一个两个表的连表查询，一开始我并未用explain分析sql语句，因为sql较简单，发现语句的书写还算规范，该走的索引也会走，一时间也无法定位问题。&ensp;&ensp;&ensp;难道是昨天修改字符集之后，insert无异常，表的增量变大，查询变得更加慢了？根据这个猜测，为了临时解决这个问题，准备将这一小段代码修改成分表查询，在内存里聚合处理。正在准备拉分支修改代码的时候，dba同学那边发消息说是索引失效了。我赶紧explain了一下刚刚的sql语句，果然，之前应该走的索引在改了字符集之后就失效了。修改字符集之后的explain结果：修改字符集之前的explain结果：原来连表查询的时候，两个表的字符集不同会导致索引失效，所以在这个如此多数据的表中进行连表查询是一件灾难性的事。找到原因后，将连表查询的另一个表的字符集同样做出修改，之后索引正常，服务也正常了。 三、总结通过这次处理线上问题，深深体会到在表数据很多的时候进行连表查询是一件多么可怕的事情，一不小心就把数据库或者服务搞崩溃了。还有一点很关键，不要像我一样看到sql简单就理所当然地以为会按照理论的情况走索引，拿到有问题的sql，一定要仔细分析，使用工具，比如explain来辅助分析sql，这样才不会遗漏问题。后续我们会对这个项目进行重构，将所有连表查询改成单表查询，然后在内存中对数据做聚合。另外这个表的数据已经到达七千多万了，修改了正确的字符集之后表的增量会更大，分表的工作也迫在眉睫。本文仅此记录下问题排查经过，如果大家也遇到了类似的问题，希望可以进行参考。]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>线上</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于红黑树的学习笔记]]></title>
    <url>%2F2018%2F09%2F23%2F%E5%85%B3%E4%BA%8E%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[前一段时间组内技术分享，正好趁这个机会好好研究了一下红黑树。在这里写下学习红黑树的一些成果和体会。 一、什么是红黑树先看一下《算法导论》中对红黑树的定义。 每个节点或者是红色，或者是黑色 根节点是黑色 每一个叶子节点(最后的空节点)是黑色的 如果一个节点是红色的，那么它的孩子节点都是黑色的 从任意一个节点到叶子节点，经过的黑色节点是一样的 这5条红黑树的定义看过之后感觉自己还是不太懂什么是红黑树，个人觉得有这种感觉的原因是定义比较抽象，不容易让人理解。那么，我们就从另一个角度入手来理解红黑树。 1. 2-3树这里先介绍一下2-3树。因为2-3树和红黑树有一定的联系，对于理解红黑树会有很大的帮助，所以我们先来看一下2-3树相关的一些性质。首先，2-3树满足二分搜索树的性质。不同的是在2-3树中，存在两种节点。一种是有两个叶子节点的，我们称作“2节点”；另一种是有三个叶子节点的，我们称作“3节点”。 如下是一整颗2-3树的示例。需要强调的是2-3树是完全平衡的树，即从根节点到任意一个叶子节点的高度都是相同的。 2. 2-3树怎样保持完全平衡性向2-3树中添加一个节点，遵循向二分搜索树中添加节点的基本思路，插入节点比当前节点小，则向当前节点的左子树添加，否则向右子树添加。不过由于2-3树特殊的性质，当要向“2节点”添加节点时，将待插入的节点与该“2节点”进行融合，组成一个新的“3节点”，如下图所示。 如果要向“3节点”添加节点，同向“2节点”添加节点一样，先组成一个临时的4节点，之后再拆分成3个“2节点”，如图所示。如果要插入的“3节点”的父节点是一个“2节点”，通过上述步骤得到的拆分过成为父节点的“2节点”，需要向原“3节点”的父节点进行融合，组成新的“3节点”。过程如下图所示。如果要插入的“3节点”的父节点是一个“3节点”，大体思路相同，向父节点进行融合，只不过此时融合后成为一个临时的“4节点”，之后要再次进行拆分。过程如图所示。 如上所述，2-3树保持了完全的平衡性。说了这么长时间的2-3树，那么2-3树和红黑树之间到底有怎样的关系，下面我们具体来看一下。 3. 2-3树与红黑树对于2-3树中的“2节点”，对应于红黑树中的“黑节点”，即相当于普通二分搜索树中的一个节点。对于2-3树中的“3节点”，相当于普通二分搜索树中的两个节点融合在一起，我们如何来描述这种融合在一起的两个节点之间的关系呢？其实很简单，如果我们将连接这两个节点的边涂成红色，就可以表示这两个节点是融合的关系，即2-3树中的一个“3节点”。那么问题又来了，对于树这种数据结构，我们在定义的时候通常都是针对节点进行定义，并没有对节点之间的边进行定义，我们如何来表示这条被涂成红色的边呢？大家都知道，对于树中的任意一个节点，都是只有一个父亲节点，所以与其父节点相连接的边可以用该节点进行表示。那么我们就可以将这两个节点中较小的节点（作为左子树的节点）涂成红色，就可以很好地表示这两个节点融合的关系了。 综合以上描述，2-3树与红黑树之间的关系，我们可以用下图很好地进行表示。我们这里说的红色节点都是向左倾斜的。看过2-3树中的两种节点和红黑树中节点的对应关系后，我们就来看一下一棵2-3树与红黑树之间的对比，如图所示。 4. 红黑树的性质讨论了2-3树与红黑树之间的关系，我们再回过头来看一下红黑树的5条定义和性质，会发现很好理解了。 每个节点或者是红色，或者是黑色这条定义很好理解，在此不做解释。 根节点是黑色根据之前说过的，红色的节点对应于2-3树中“3节点”中较小的那个节点，拆成两个“2节点”的话则是一个左子树的节点，即红色的节点总是可以和其父节点进行融合，所以红色节点一定有父节点，显然根节点不能是红色，所以根节点是黑色。 每一个叶子节点(最后的空节点)是黑色的这条性质和第2条是对应的。对于叶子节点（最后的空节点），一颗空树的根节点也为黑色，所以与其说第三条是一条性质，不如说也是一个定义。 如果一个节点是红色的，那么它的孩子节点都是黑色的根据上面2-3树与红黑树两种节点的对比图，我们很容易看到，红色节点的两个子树，对应2-3树中的话，要么是一个“2节点”，要么是一个“3节点”，而不管是“2节点”还是“3节点”，相连的第一个节点都是黑色的，所以说红色节点的孩子节点都是黑色的。 从任意一个节点到叶子节点，经过的黑色节点是一样的根据2-3树与红黑树的关系对比图，可以发现，红黑树中一个黑色节点对应2-3树中一整个节点（“2节点”或“3节点”），而2-3树是完全平衡的树，从根节点到任意路径的叶子节点，经过的节点个数都是相同的，对应红黑树中，即从任意节点到叶子节点，经过的黑色节点是一样的。 二、 红黑树添加元素回忆刚刚提到的向2-3树中添加元素的过程，或者添加进一个“2节点”，形成一个“3节点”，或者添加进一个“3节点”，形成一个临时的“4节点”。理解了2-3树如何添加节点，对应红黑树就很好理解了。很容易知道，我们总是会将待插入的节点向父节点进行融合，所以我们将待插入的节点看成红色,即永远添加红色节点。向一棵空树添加节点42。插入后，该节点是根节点，根据红黑树的性质，根节点必须是黑色，所以讲该节点染成黑色。 若向如图的红黑树中添加节点37。因为37比42小，所以添加在42的左子树，对应2-3树中，形成一个“3节点”。若向如图的红黑树中添加节点42。因为42比37大，所以添加在37的右子树。这样的话红色节点就出现在了一个节点的右子树中，所以此时需要进行左旋转，让树满足红黑树的性质。 1. 左旋转对于一般的情况，如何进行左旋转呢？我们要对下图的红黑树进行左旋转。 首先将node节点与x节点断开，其次将x的左子树作为node的右子树。然后再将node作为x新的左子树，之后要把x的颜色染成node的颜色，最后将node的颜色变为红色，这样就完成了左旋转的操作。 2. 颜色翻转（flipColors）向红黑树中插入节点66，很容易知道插入到42右子树的位置，对应于2-3树的插入如图所示。 然而上面我们说到，我们总是要将新拆分出来的树的父亲节点向上进行融合，即这个父亲节点在红黑树中总是红色的，根据红黑树的性质，该父亲节点的两个孩子节点一定是黑色的。这样就需要将上一步形成的树进行颜色的翻转，变成如下图的形态。 3. 右旋转向如图的红黑树中插入节点12，根据二分搜索树插入的操作，此时会形成一条链状的结构，对于2-3树中则是变形成为图中的样子，才能保证平衡性。所以在红黑树中，也要通过变形，变成与2-3树对应的形态。这种情况的变形操作，称为“右旋转”。 一般的情况，右旋转操作同上面的左旋转操作很类似，下面我们一起来看一下过程。我们要对下图的红黑树进行右旋转的操作。首先将node和x节点断开，将x的右子树T1作为node的左子树。其次将node作为x的右子树。接着要把x的颜色染成原来node的颜色，把node染成红色。然后很显然，需要再进行一次颜色翻转操作，才能满足红黑树的性质。有一种比较复杂的情况，向下图的红黑树中插入节点40,要满足的红黑树的性质我们需要怎么操作呢？对应2-3树中最终的形态，第一步我们可以通过一次左旋转，变成下图的样子。会发现，这样就变成了上面说到的需要右旋转的形态，所以再进行一次右旋转和颜色翻转，就可以满足红黑树的性质了。 4.红黑树插入总结上面分情况讨论了向红黑树中添加节点的各种情况，这里总结一下。其实根据上面的讨论，我们可以发现，最后一种复杂的情况可以涵盖其余简单的情况，复杂的操作包含了左旋转、右旋转、颜色翻转，这三种操作，完全可以保持红黑树的性质。下面的一张图，很好的总结了向红黑树中添加节点不同情况下的过程。 三、红黑树删除元素关于红黑树的删除操作，比插入操作要复杂一些，需要分情况进行讨论。下面我们具体来看一下。红黑树的删除操作大体分为2步： 二分搜索树删除节点 删除修复操作 红黑树的删除首先满足二分搜索树的删除，然后对删除节点后的树进行修复操作，让其重新满足红黑树的5条性质。对于二分搜索树的删除，这里就不再赘述，我们主要讨论红黑树的删除修复操作。以下所说的当前节点意思是通过二分搜索树的方式删除要删除的节点后，代替原来节点的节点。当删除节点是红色节点时,那么原来红黑树的性质依旧保持，此时不用做修复操作。当删除节点是黑色节点时,情况很多，我们分情况讨论。 1.简单情况 当前节点是红色节点直接把当前节点染成黑色,结束，红黑树的性质全部恢复。 当前节点是黑色节点，并且是根节点什么都不做，直接结束。 2.复杂情况 N、S、SL、SR、P都为黑色其中N是上述的当前节点，S是N的兄弟节点，P是N的父节点，SL和SR是N兄弟节点的左右孩子节点。 此时将S染成红色，这样经过N路径的黑色节点就和N的兄弟子树中的黑色节点相同了，但是经过P节点的黑色节点少了一个，此时需要将P当做新的N再进行操作，具体怎么操作可以见以下一些情况。 N、S、SL、SR为黑色，P为红色 此时将P和S的颜色进行交换,P成为了黑色,它为经过节点N的路径添加了一个黑色节点，从而补偿了被删除的黑色节点。S的颜色只是上移到父节点P上,因而经过S节点路径的黑色节点的数目也没有发生改变。 N、S为黑色，SR为红色图中蓝色节点表示该节点可以为黑色也可以为红色，即对该节点的颜色没有要求。此时将以P为根的子树进行左旋转然后交换P和S的颜色将SR染成黑色调整后经由N的路径的黑色节点数比调整前增加了一个，恰好补偿了被删除的黑色节点。对于不经过N但经过其他节点的任意一个路径来说，它们贡献的黑色节点数目不变。 N、S为黑色，SL为红色，SR为黑色此时，将以S为根的子树进行右旋转接着交换S和SL的颜色节点SL的左孩子在旋转前后不变，而SL原来为红色，所以SL的左孩子必定为黑色。所以旋转后对于N节点来说，相当于情况3。之后再通过情况3中的描述进行操作。整体上情况4需要进行一次右旋转和一次左旋转。 N为黑色，S为红色此时，将以P为根的子树进行左旋转将P和S颜色交换经过这样的变换后，把该情形转化成了N为黑色，其兄弟为黑色的情形，再通过以上描述的几种情况进行变换，最终保持红黑树的性质。红黑树删除的各种复杂的情况，以上都进行了讨论，虽然比较繁琐，但是认真研究后还是可以理解的，并没有之前想象地那么困难。 四、红黑树的性能红黑树的增删改查的复杂度显然是O(logn)级别的，通常说红黑树是统计性能更优的树结构。为什么说统计性能更优呢？因为若是单纯的读操作，AVL树的性能比红黑树强一些，红黑树不是严格的平衡树，它是保持“黑平衡”的树。对于红黑树，最坏的情况，是树中最左侧的节点的左子树都是红色的节点，即对应2-3树中的“3节点”，所以这时红黑树的高度就是2logn（除了logn个黑色节点外，还有logn个红色节点），红黑树要比AVL树要高一些。所以从单纯的查询性能来说，红黑树的性能并没有AVL树强。对于插入删除操作来说，红黑树相比于AVL树减少了左旋转或右旋转的次数，所以红黑树的插入删除的性能比AVL树强一些。综合增删改查各方面的性能，红黑树的综合性能比较高。 五、红黑树的应用 Java中的TreeMap，Java8中HashMap的TreeNode节点采用了红黑树实现 C++中，STL的map和set也应用了红黑树 Linux中完全公平调度算法CFS(Completely Fair Schedule) 用红黑树管理进程控制块epoll在内核中的实现，用红黑树管理事件块 Nginx中，用红黑树管理timer等 这次的分享，主要对红黑树的性质以及向红黑树中插入、删除元素进行分析，对于红黑树的应用并没有很深入的进行研究，如上所述的几种红黑树的应用，也只是了解，还需要在以后的工作学习中进行完善。以上是本人对红黑树学习的一些成果和心得，记下来让自己所学的知识体系化，也方便日后的复习回顾。]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>红黑树</tag>
      </tags>
  </entry>
</search>

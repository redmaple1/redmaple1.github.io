<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Redmaple1的博客</title>
  
  <subtitle>我的个人技术博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://redmapleren.com/"/>
  <updated>2019-04-30T10:02:09.381Z</updated>
  <id>http://redmapleren.com/</id>
  
  <author>
    <name>Xiaoya Ren</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>记一次大批量物理删除数据</title>
    <link href="http://redmapleren.com/2019/04/29/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%A4%A7%E6%89%B9%E9%87%8F%E7%89%A9%E7%90%86%E5%88%A0%E9%99%A4%E6%95%B0%E6%8D%AE/"/>
    <id>http://redmapleren.com/2019/04/29/记一次大批量物理删除数据/</id>
    <published>2019-04-29T03:00:00.000Z</published>
    <updated>2019-04-30T10:02:09.381Z</updated>
    
    <content type="html"><![CDATA[<p>&ensp;&ensp;&ensp;接上次闹钟项目更改字符集之后，这几天又需要对线上数据做处理。背景是，同步闹钟的时候会把用户之前删除过的闹钟都同步下来，而删除的闹钟在客户端没有任何显示，也没有任何恢复的操作，对于用户来说其实是完全没有用的数据。当用户的无用历史闹钟增多到一定数量，同步的时候，客户端上报的数据body就特别大，已经超过了Nginx配置的request最大限制，这样就导致了部分老用户无法同步的情况。解决思路其实很简单，将客户端的上报策略修改成分批上传，服务端分批的返回，最后的结果客户端在本地做聚合，显示给用户。但是这需要客户端和服务端共同修改，客户端还要发版审核，现在需要一种比较快速的方式，让用户在尽可能短的时间内可以进行同步。最后决定将数据库中2018年以前用户无用的闹钟进行删除，找到dba同学商量要删除数据，但是很不幸，dba同学告知我们目前他们没有成熟的工具操作，让我们自己写程序删除，他们可以负责备份数据。看来只能靠自己了，接下来就看一下从分析到实现整个删除任务的具体过程。  </p><h2 id="一、思路分析"><a href="#一、思路分析" class="headerlink" title="一、思路分析"></a>一、思路分析</h2><p>&ensp;&ensp;&ensp;需要进行删除的这张表是一个很宽的数据量很大的表，当前共有七千多万条数据，经过筛选查询，发现2018年之前且状态为无效的闹钟数量达到了五千多万，也就是说现在需求是要物理删除这五千多万条数据。需求明确了，下面就要考虑几个问题。</p><ol><li>要删除的五千多万条数据如何定位？</li><li>怎样高效地删除这么大量的数据同时保证负载正常？</li><li>怎样保证集群环境下，删除任务只执行一次？  </li></ol><p>我们分别看一下解决这些问题的思路。  </p><h3 id="1-定位目标数据"><a href="#1-定位目标数据" class="headerlink" title="1.定位目标数据"></a>1.定位目标数据</h3><p>&ensp;&ensp;&ensp;表中主要字段包括user_id,status,init_time,分别表示闹钟所属的用户id、闹钟状态、闹钟初始化时间。删除的大体思路是通过in user_id字段来delete，那么如何找到要in哪些user_id呢？从上面的分析可以知道，这张表拥有很大的数据量，想要一次delete是不可能的事情，需要进行分批删除，每次in一部分user_id。那么每次的user_id如何获取呢？可以通过分页排序的group by语句得到分批的user_id。  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> user_id <span class="keyword">from</span> clocks <span class="keyword">order</span> <span class="keyword">by</span> user_id <span class="keyword">group</span> <span class="keyword">by</span> user_id <span class="keyword">limit</span> <span class="number">0</span>,<span class="number">500</span>;</span><br></pre></td></tr></table></figure><p>&ensp;&ensp;&ensp;上面的分页查询看上去没什么问题，但是随着翻页次数增大，效率也越来越慢，假设我们翻到了2000页，这个语句查询的2000之前的数据都是无用的，效率特别低下。由数据量分析可知，这张表里通过user_id分组，可以得到200W+数据，如果我们每次分页查询500条，计算可得 最后我们需要将 200W / 500 作为limit的起点，这样的查询是灾难性的。但是通过下面的sql修改，可以大大提高分页的查询效率。  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> user_id <span class="keyword">from</span> clocks <span class="keyword">where</span> user_id &gt; <span class="number">0</span> <span class="keyword">order</span> <span class="keyword">by</span> user_id <span class="keyword">group</span> <span class="keyword">by</span> user_id <span class="keyword">limit</span> <span class="number">500</span>;</span><br><span class="line"><span class="keyword">select</span> user_id <span class="keyword">from</span> clocks <span class="keyword">where</span> user_id &gt; <span class="number">500</span> <span class="keyword">order</span> <span class="keyword">by</span> user_id <span class="keyword">group</span> <span class="keyword">by</span> user_id <span class="keyword">limit</span> <span class="number">500</span>;</span><br><span class="line"><span class="keyword">select</span> user_id <span class="keyword">from</span> clocks <span class="keyword">where</span> user_id &gt; <span class="number">1000</span> <span class="keyword">order</span> <span class="keyword">by</span> user_id <span class="keyword">group</span> <span class="keyword">by</span> user_id <span class="keyword">limit</span> <span class="number">500</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>&ensp;&ensp;&ensp;通过where过滤当前页之前的数据，可以大大提高查询效率。只需要每次记下当次分页结果中最大的user_id，下次分页将此user_id作为分页起始条件进行过滤即可。因为我们使用order by进行排序，查询结果都是有序的，可以将每次的user_id结果放进一个LinkedList中，每次使用的时候peekLast()就能得到当前分组的最大user_id。定位目标数据的思路大体就是这样，思路清晰后代码实现也是很容易的。  </p><figure class="highlight java"><figcaption><span>ClockDeleteUser.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClockDeleteUser</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下一次分页的起始user_id</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> nextFirstUserId;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> LinkedList&lt;Long&gt; userIds;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> perLimit;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ClockDeleteUser</span><span class="params">(<span class="keyword">long</span> nextFirstUserId,<span class="keyword">int</span> perLimit)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.nextFirstUserId = nextFirstUserId;</span><br><span class="line">        <span class="keyword">this</span>.perLimit = perLimit;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  <figure class="highlight java"><figcaption><span>ClockDeleteService.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClockDeleteService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> DELETE_USER_PER_LIMIT = <span class="number">500</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> SyncDao syncDao;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取删除语句中in的userId的信息集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Long&gt;&gt; getDeleteUser()&#123;</span><br><span class="line">        List&lt;List&lt;Long&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">long</span> nextFirstUserId = <span class="number">0</span>;</span><br><span class="line">        ClockDeleteUser clockDeleteUser = <span class="keyword">new</span> ClockDeleteUser(nextFirstUserId,DELETE_USER_PER_LIMIT);</span><br><span class="line">        LinkedList&lt;Long&gt; userIds = syncDao.getClockDeleteUserIds(clockDeleteUser);</span><br><span class="line">        <span class="keyword">while</span> (CollectionUtils.isNotEmpty(userIds))&#123;</span><br><span class="line">            result.add(userIds);</span><br><span class="line">            clockDeleteUser.setNextFirstUserId(userIds.peekLast());</span><br><span class="line">            userIds = syncDao.getClockDeleteUserIds(clockDeleteUser);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 按照userId集合删除无用的闹钟</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> userIds</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">deleteUnusedClock</span><span class="params">(List&lt;Long&gt; userIds)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 分批删除无用闹钟</span></span><br><span class="line">        <span class="keyword">return</span> syncDao.deleteUnusedClocksByUserInitTime(userIds);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  <h3 id="2-多线程删除"><a href="#2-多线程删除" class="headerlink" title="2.多线程删除"></a>2.多线程删除</h3><p>&ensp;&ensp;&ensp;找到了每次分批的user_id条件，接下来就可以进行删除操作了。这么庞大的数据量，每次串行执行delete where，明显效率很低，估计删除完这些数据也要进行几个小时吧。这时我们很容易地想到了使用多个线程同时进行delete操作。因为user_id字段是这张表的索引，所以delete的时候走索引，并不会锁住整个表，所以我们可以使用多个线程同时进行删除。但是由于数据量大，分组要达4000+，我们要使用多少个线程同时工作呢？<br>这里我们通过 Runtime.getRuntime().availableProcessors() 获取当前可用处理器数量，用来创建线程池。<br>&ensp;&ensp;&ensp;我们使用 Executors.newFixedThreadPool() 创建固定线程数的线程池，传入的参数就是上面获取的处理器的数量。当工作线程到达了处理器数量，新进来的任务便会进入阻塞队列等待，待工作线程中有任务完成，阻塞队列中的任务再执行。线程池的工作原理，大家应该都已经很熟悉了，在此就不多说了。<br>多线程执行当然能提高效率，但是我们能将这4000+的任务一下子提交给线程池来执行吗？这样的话cpu会有突然增长，这里我们可以使用限流策略，控制任务进入线程池的速度。Google Guava中提供了一个很好用的限流工具，它就是 RateLimiter，一个基于令牌桶算法实现的限流器，想必大家也都知道。使用RateLimiter可以很方便地实现限流。<br>&ensp;&ensp;&ensp;通过以上的思考，多线程删除也可以很简单地实现，在文章的后面我会给出实现代码。  </p><h3 id="3-集群中单点执行任务"><a href="#3-集群中单点执行任务" class="headerlink" title="3.集群中单点执行任务"></a>3.集群中单点执行任务</h3><p>&ensp;&ensp;&ensp;应用部署在集群中，但是我们需求的任务只需要一台机器执行即可。我们如何来保证集群中只有一台机器执行这个删除任务呢？<br>&ensp;&ensp;&ensp;我们可以使用Redis来实现。大体思路如下：<br>&ensp;&ensp;&ensp;判断标识删除任务执行的Key是否存在，存在的话直接返回，不存在则使用 SETNX 尝试设置Key的value为当前自己的Pid，再次获取key对应的value值，若value和自己当前的pid不同，说明不是当前节点获取的锁，不能执行任务，只有value和当前自己的pid相同时才执行删除任务。这样就可以保证集群中只有一个节点执行了删除任务，在任务执行结束之后要删除key。下面给出流程图，思路一目了然。  </p><div align="center"><br><img src="https://hexo-rxy.oss-cn-beijing.aliyuncs.com/database/delete_clock/%E5%88%A0%E9%99%A4%E4%BB%BB%E5%8A%A1redis.png" width="50%" height="50%"><br></div><h3 id="4-在哪里触发任务"><a href="#4-在哪里触发任务" class="headerlink" title="4.在哪里触发任务"></a>4.在哪里触发任务</h3><p>&ensp;&ensp;&ensp;分析了如何定位以及删除数据，那我们如何触发任务的执行呢？这里我在配置文件中设置了一个开关，用来标识本次启动是否需要执行删除任务。这个开关和上面提到的redis key共同决定是否在当前节点执行任务。<br>&ensp;&ensp;&ensp;什么时机进行删除呢？因为删除任务中使用了spring bean service，所以应该在spring容器初始化bean完成后执行删除任务。<br>&ensp;&ensp;&ensp;可以通过实现 ApplicationRunner 接口，实现接口的run方法来执行我们的任务。查阅springboot官方文档<br><blockquote><footer><strong>@SpringbootDoc</strong><cite><a href="https://docs.spring.io/spring-boot/docs/2.1.4.RELEASE/reference/htmlsingle/#using-boot" target="_blank" rel="noopener">docs.spring.io/spring-boot/docs/2.1.4.RELEASE/reference/htmlsingle/#using-boot</a></cite></footer></blockquote></p><div align="center"><br><img src="https://hexo-rxy.oss-cn-beijing.aliyuncs.com/database/delete_clock/ApplicationRunner%E6%96%87%E6%A1%A3.png" width="100%" height="100%"><br></div>  <h2 id="二、代码实现"><a href="#二、代码实现" class="headerlink" title="二、代码实现"></a>二、代码实现</h2><p>&ensp;&ensp;&ensp;通过以上分析，实现思路已经非常清晰，下面给出实现代码，仅供参考。<br><figure class="highlight java"><figcaption><span>DeleteClockTask.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeleteClockTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;Long&gt; userIds;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ClockDeleteService clockDeleteService;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DeleteClockTask</span><span class="params">(String name, List&lt;Long&gt; userIds)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.userIds = userIds;</span><br><span class="line">        <span class="keyword">this</span>.clockDeleteService = (ClockDeleteService) SpringContextUtils.getBeanByClass(ClockDeleteService.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">"delete clock task &#123;&#125; start..."</span>, name);</span><br><span class="line">        clockDeleteService.deleteUnusedClock(userIds);</span><br><span class="line">        log.info(<span class="string">"delete unused clock task &#123;&#125; end."</span>, name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  </p><figure class="highlight java"><figcaption><span>InitialBeanHandler.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InitialBeanHandler</span> <span class="keyword">implements</span> <span class="title">ApplicationRunner</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ClockDeleteService clockDeleteService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;task.delete.status&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> deleteSwitch;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedissonHandler redissonHandler;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">long</span> TASK_EXPIRE_MILLS_TIME = <span class="number">60</span> * <span class="number">60</span> * <span class="number">1000</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String DELETE_CLOCK_TASK_KEY = <span class="string">"delete_used_clock_running"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> ExecutorService pool = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors());</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(ApplicationArguments args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 先判断删除开关是否开启</span></span><br><span class="line">        log.info(<span class="string">"删除无用闹钟开关 deleteSwitch : "</span> + deleteSwitch);</span><br><span class="line">        <span class="comment">// 若开关开启，并且当前没有节点在执行删除任务，则执行删除任务</span></span><br><span class="line">        <span class="comment">//通过redis查询是否有节点已经运行了删除任务</span></span><br><span class="line">        <span class="keyword">boolean</span> taskRunning = redissonHandler.exists(DELETE_CLOCK_TASK_KEY);</span><br><span class="line"></span><br><span class="line">        List&lt;DeleteClockTask&gt; tasks = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (deleteSwitch == <span class="number">1</span> &amp;&amp; !taskRunning) &#123;</span><br><span class="line">            <span class="comment">//当前节点执行删除任务，设置redis中的任务状态</span></span><br><span class="line">            String nowPid = ManagementFactory.getRuntimeMXBean().getName();</span><br><span class="line">            redissonHandler.setNX(DELETE_CLOCK_TASK_KEY, nowPid, TASK_EXPIRE_MILLS_TIME);</span><br><span class="line">            String taskRunningPid = redissonHandler.get(DELETE_CLOCK_TASK_KEY, String.class);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!StringUtils.equals(taskRunningPid, nowPid)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//获取分批删除的userId的list</span></span><br><span class="line">            List&lt;List&lt;Long&gt;&gt; deleteUsersList = clockDeleteService.getDeleteUser();</span><br><span class="line">            <span class="keyword">if</span> (CollectionUtils.isNotEmpty(deleteUsersList)) &#123;</span><br><span class="line">                <span class="keyword">int</span> size = deleteUsersList.size();</span><br><span class="line">                log.info(<span class="string">"There are &#123;&#125; delete clock tasks totally."</span>, size);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                    List&lt;Long&gt; userIds = deleteUsersList.get(i);</span><br><span class="line">                    DeleteClockTask task = <span class="keyword">new</span> DeleteClockTask(<span class="string">"deleteTask"</span> + i, userIds);</span><br><span class="line">                    tasks.add(task);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//限流</span></span><br><span class="line">            RateLimiter rateLimiter = RateLimiter.create(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (DeleteClockTask task : tasks) &#123;</span><br><span class="line">                log.info(<span class="string">"delete clock task &#123;&#125; wait time &#123;&#125;"</span>, task.getName(), rateLimiter.acquire());</span><br><span class="line">                pool.execute(task);</span><br><span class="line">                log.info(<span class="string">"delete clock task &#123;&#125; finished."</span>, task.getName());</span><br><span class="line">            &#125;</span><br><span class="line">            log.info(<span class="string">"delete clock tasks all finished"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//执行完成，将redis中标志任务执行状态的key删除</span></span><br><span class="line">            redissonHandler.del(DELETE_CLOCK_TASK_KEY);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  <h2 id="三、线上执行"><a href="#三、线上执行" class="headerlink" title="三、线上执行"></a>三、线上执行</h2><p>&ensp;&ensp;&ensp;经过测试环境反复测试，最终挑了个风和日丽的日子，准备在生产环境执行。<br>&ensp;&ensp;&ensp;合并master，开始部署，盯着日志，静静等待…<br>&ensp;&ensp;&ensp;线上删除任务共分为了4014个组，按每秒钟2组的速度进入线程池,开始执行删除任务，观察cpu使用率，基本稳定，没有出现激增。半个多小时后，所有任务执行完成。一共删除了58115102条数据，至此这次删除历史数据的任务完成。<br>&ensp;&ensp;&ensp;第一次在线上物理删除这么大量的数据，仅此记录一下本次处理的思路和实现方法。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;ensp;&amp;ensp;&amp;ensp;接上次闹钟项目更改字符集之后，这几天又需要对线上数据做处理。背景是，同步闹钟的时候会把用户之前删除过的闹钟都同步下来，而删除的闹钟在客户端没有任何显示，也没有任何恢复的操作，对于用户来说其实是完全没有用的数据。当用户的无用历史闹钟增多到一
      
    
    </summary>
    
      <category term="数据库" scheme="http://redmapleren.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="数据库" scheme="http://redmapleren.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="线上" scheme="http://redmapleren.com/tags/%E7%BA%BF%E4%B8%8A/"/>
    
      <category term="多线程" scheme="http://redmapleren.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>记一次数据库更改字符集踩的坑</title>
    <link href="http://redmapleren.com/2019/04/19/%E8%AE%B0%E4%B8%80%E6%AC%A1%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9B%B4%E6%94%B9%E5%AD%97%E7%AC%A6%E9%9B%86%E8%B8%A9%E7%9A%84%E5%9D%91/"/>
    <id>http://redmapleren.com/2019/04/19/记一次数据库更改字符集踩的坑/</id>
    <published>2019-04-19T06:30:00.000Z</published>
    <updated>2019-04-19T09:19:21.571Z</updated>
    
    <content type="html"><![CDATA[<p>最近接手了一个闹钟App的后端项目，其中有个功能就是用户可以将本地闹钟同步到服务器，以便更换设备后能从服务器同步数据到新设备。但是这几天观察后台日志发现，同步的时候总是ERROR，定位错误发现跟数据库的字符集有关，在此记录一下本次线上错误的排查过程。</p><h2 id="一、定位ERROR"><a href="#一、定位ERROR" class="headerlink" title="一、定位ERROR"></a>一、定位ERROR</h2><p>通过Kibana查看最近的ERROR日志，可发现如下的错误描述。<br><img src="https://hexo-rxy.oss-cn-beijing.aliyuncs.com/database/index_accident/incorrect.png" width="100%" height="100%"><br><br>&ensp;&ensp;&ensp;很明显可以发现，是因为insert的时候插入的数据不符合该列的要求。进而查看插入的数据，定位到插入内容含有特殊字符，比如emoji表情和其他一些字符。查询table的字符集发现这张表是utf8字符集，并不是utf8mb4的字符集，所以报这个错也是很正常了。看到这里你可能会问，这个问题应该在很久之前就应该发现了，为什么这几天才把它揪出来呢？这个项目很早了，包括后端和客户端，经过客户端同学的代码筛查，发现由于历史的原因，客户端对同步的结果的处理存在bug，导致后台同步失败某冲情况下也会提示同步成功，所以前台并不会暴露这个问题。<br>&ensp;&ensp;&ensp;所以当时建表使用的utf8字符集已经不能满足用户的自定义名称的需求，需要变更这张表的字符集为utf8mb4。但是一查数据，这张表就有七千多万的数据，更改字符集的话对之前的内容是否有影响，要执行多久？问题找到了，就开始找dba同学商量，最后决定先创建一张utf8mb4的新表，将原来的数据导入到新表，完成后，再将原表rename成新表，完成切换。说干就干，晚上提了工单，dba开始执行。</p><h2 id="二、黎明前的黑暗"><a href="#二、黎明前的黑暗" class="headerlink" title="二、黎明前的黑暗"></a>二、黎明前的黑暗</h2><p>&ensp;&ensp;&ensp;第二天早上起床，发现接到了n多条服务报警，正是昨天更改字符集的服务。到了公司立马查看服务日志，发现服务挂了，重新部署启动，没有两分钟又挂了。这是什么原因呢？没有更改任何代码，只更改了一个表的字符集，整个服务就崩了吗？这是什么道理，一时间也是很懵。这时候dba那边发来了一长串slow sql，是一个两个表的连表查询，一开始我并未用explain分析sql语句，因为sql较简单，发现语句的书写还算规范，该走的索引也会走，一时间也无法定位问题。<br>&ensp;&ensp;&ensp;难道是昨天修改字符集之后，insert无异常，表的增量变大，查询变得更加慢了？根据这个猜测，为了临时解决这个问题，准备将这一小段代码修改成分表查询，在内存里聚合处理。正在准备拉分支修改代码的时候，dba同学那边发消息说是索引失效了。我赶紧explain了一下刚刚的sql语句，果然，之前应该走的索引在改了字符集之后就失效了。<br>修改字符集之后的explain结果：<br><img src="https://hexo-rxy.oss-cn-beijing.aliyuncs.com/database/index_accident/%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88explain.png" width="100%" height="100%"><br><br>修改字符集之前的explain结果：<br><img src="https://hexo-rxy.oss-cn-beijing.aliyuncs.com/database/index_accident/%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88explain.png" width="100%" height="100%"><br><br>原来连表查询的时候，两个表的字符集不同会导致索引失效，所以在这个如此多数据的表中进行连表查询是一件灾难性的事。<br>找到原因后，将连表查询的另一个表的字符集同样做出修改，之后索引正常，服务也正常了。  </p><h2 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h2><p>通过这次处理线上问题，深深体会到在表数据很多的时候进行连表查询是一件多么可怕的事情，一不小心就把数据库或者服务搞崩溃了。还有一点很关键，不要像我一样看到sql简单就理所当然地以为会按照理论的情况走索引，拿到有问题的sql，一定要仔细分析，使用工具，比如explain来辅助分析sql，这样才不会遗漏问题。后续我们会对这个项目进行重构，将所有连表查询改成单表查询，然后在内存中对数据做聚合。另外这个表的数据已经到达七千多万了，修改了正确的字符集之后表的增量会更大，分表的工作也迫在眉睫。<br>本文仅此记录下问题排查经过，如果大家也遇到了类似的问题，希望可以进行参考。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近接手了一个闹钟App的后端项目，其中有个功能就是用户可以将本地闹钟同步到服务器，以便更换设备后能从服务器同步数据到新设备。但是这几天观察后台日志发现，同步的时候总是ERROR，定位错误发现跟数据库的字符集有关，在此记录一下本次线上错误的排查过程。&lt;/p&gt;
&lt;h2 id=
      
    
    </summary>
    
      <category term="数据库" scheme="http://redmapleren.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="数据库" scheme="http://redmapleren.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="线上" scheme="http://redmapleren.com/tags/%E7%BA%BF%E4%B8%8A/"/>
    
  </entry>
  
  <entry>
    <title>关于红黑树的学习笔记</title>
    <link href="http://redmapleren.com/2018/09/23/%E5%85%B3%E4%BA%8E%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://redmapleren.com/2018/09/23/关于红黑树的学习笔记/</id>
    <published>2018-09-23T07:37:05.000Z</published>
    <updated>2019-04-19T06:30:23.959Z</updated>
    
    <content type="html"><![CDATA[<p>前一段时间组内技术分享，正好趁这个机会好好研究了一下红黑树。在这里写下学习红黑树的一些成果和体会。</p><h2 id="一、什么是红黑树"><a href="#一、什么是红黑树" class="headerlink" title="一、什么是红黑树"></a>一、什么是红黑树</h2><p>先看一下《算法导论》中对红黑树的定义。</p><ol><li>每个节点或者是红色，或者是黑色</li><li>根节点是黑色</li><li>每一个叶子节点(最后的空节点)是黑色的</li><li>如果一个节点是红色的，那么它的孩子节点都是黑色的</li><li>从任意一个节点到叶子节点，经过的黑色节点是一样的    <div style="display:none"><br><img src="https://hexo-rxy.oss-cn-beijing.aliyuncs.com/data_structure/RBTree/%E5%B9%B3%E9%93%BA%E5%B0%81%E9%9D%A2%20%281%29.png" alt="post-cover"><br></div></li></ol><p>这5条红黑树的定义看过之后感觉自己还是不太懂什么是红黑树，个人觉得有这种感觉的原因是定义比较抽象，不容易让人理解。那么，我们就从另一个角度入手来理解红黑树。</p><h3 id="1-2-3树"><a href="#1-2-3树" class="headerlink" title="1. 2-3树"></a>1. 2-3树</h3><p>这里先介绍一下2-3树。因为2-3树和红黑树有一定的联系，对于理解红黑树会有很大的帮助，所以我们先来看一下2-3树相关的一些性质。<br>首先，2-3树满足二分搜索树的性质。不同的是在2-3树中，存在两种节点。一种是有两个叶子节点的，我们称作“2节点”；另一种是有三个叶子节点的，我们称作“3节点”。    </p><div align="center"><br><img src="https://hexo-rxy.oss-cn-beijing.aliyuncs.com/data_structure/RBTree/2-3%E6%A0%91%E8%8A%82%E7%82%B9%E6%A6%82%E8%A7%88.png" width="50%" height="50%"><br></div><br>如下是一整颗2-3树的示例。需要强调的是2-3树是完全平衡的树，即从根节点到任意一个叶子节点的高度都是相同的。<br><div align="center"><br><img src="https://hexo-rxy.oss-cn-beijing.aliyuncs.com/data_structure/RBTree/2-3%E6%A0%91%E6%95%B4%E4%BD%93%E7%A4%BA%E4%BE%8B.png" width="60%" height="60%"><br></div>  <h3 id="2-2-3树怎样保持完全平衡性"><a href="#2-2-3树怎样保持完全平衡性" class="headerlink" title="2. 2-3树怎样保持完全平衡性"></a>2. 2-3树怎样保持完全平衡性</h3><p>向2-3树中添加一个节点，遵循向二分搜索树中添加节点的基本思路，插入节点比当前节点小，则向当前节点的左子树添加，否则向右子树添加。不过由于2-3树特殊的性质，当要向“2节点”添加节点时，将待插入的节点与该“2节点”进行融合，组成一个新的“3节点”，如下图所示。  </p><div align="center"><br><img src="https://hexo-rxy.oss-cn-beijing.aliyuncs.com/data_structure/RBTree/2-3%E6%A0%91%E6%8F%92%E5%85%A52%E8%8A%82%E7%82%B9.png" width="50%" height="50%"><br></div><br>如果要向“3节点”添加节点，同向“2节点”添加节点一样，先组成一个临时的4节点，之后再拆分成3个“2节点”，如图所示。<br><div align="center"><br><img src="https://hexo-rxy.oss-cn-beijing.aliyuncs.com/data_structure/RBTree/2-3%E6%A0%91%E6%8F%92%E5%85%A53%E8%8A%82%E7%82%B9.png" width="60%" height="60%"><br></div><br>如果要插入的“3节点”的父节点是一个“2节点”，通过上述步骤得到的拆分过成为父节点的“2节点”，需要向原“3节点”的父节点进行融合，组成新的“3节点”。过程如下图所示。<br><div align="center"><br><img src="https://hexo-rxy.oss-cn-beijing.aliyuncs.com/data_structure/RBTree/2-3%E6%A0%91%E6%8F%92%E5%85%A53%E8%8A%82%E7%82%B9-%E7%88%B6%E8%8A%82%E7%82%B9.png" width="80%" height="80%"><br></div><br>如果要插入的“3节点”的父节点是一个“3节点”，大体思路相同，向父节点进行融合，只不过此时融合后成为一个临时的“4节点”，之后要再次进行拆分。过程如图所示。<br><div align="center"><br><img src="https://hexo-rxy.oss-cn-beijing.aliyuncs.com/data_structure/RBTree/2-3%E6%A0%91%E6%8F%92%E5%85%A53%E8%8A%82%E7%82%B9-%E7%88%B6%E8%8A%82%E7%82%B93.png" width="80%" height="80%"><br></div>  <p>如上所述，2-3树保持了完全的平衡性。说了这么长时间的2-3树，那么2-3树和红黑树之间到底有怎样的关系，下面我们具体来看一下。  </p><h3 id="3-2-3树与红黑树"><a href="#3-2-3树与红黑树" class="headerlink" title="3. 2-3树与红黑树"></a>3. 2-3树与红黑树</h3><p>对于2-3树中的“2节点”，对应于红黑树中的“黑节点”，即相当于普通二分搜索树中的一个节点。<br>对于2-3树中的“3节点”，相当于普通二分搜索树中的两个节点融合在一起，我们如何来描述这种融合在一起的两个节点之间的关系呢？其实很简单，如果我们将连接这两个节点的边涂成红色，就可以表示这两个节点是融合的关系，即2-3树中的一个“3节点”。那么问题又来了，对于树这种数据结构，我们在定义的时候通常都是针对节点进行定义，并没有对节点之间的边进行定义，我们如何来表示这条被涂成红色的边呢？大家都知道，对于树中的任意一个节点，都是只有一个父亲节点，所以与其父节点相连接的边可以用该节点进行表示。那么我们就可以将这两个节点中较小的节点（作为左子树的节点）涂成红色，就可以很好地表示这两个节点融合的关系了。  </p><div align="center"><br><img src="https://hexo-rxy.oss-cn-beijing.aliyuncs.com/data_structure/RBTree/2-3%E6%A0%91%E4%B8%8E%E7%BA%A2%E9%BB%91%E6%A0%91-3%E8%8A%82%E7%82%B9%E5%AF%B9%E5%BA%94.png" width="60%" height="60%"><br></div><br>综合以上描述，2-3树与红黑树之间的关系，我们可以用下图很好地进行表示。我们这里说的红色节点都是向左倾斜的。<br><div align="center"><br><img src="https://hexo-rxy.oss-cn-beijing.aliyuncs.com/data_structure/RBTree/2-3%E6%A0%91%E4%B8%8E%E7%BA%A2%E9%BB%91%E6%A0%91-%E8%8A%82%E7%82%B9%E7%BB%BC%E5%90%88.png" width="80%" height="80%"><br></div><br>看过2-3树中的两种节点和红黑树中节点的对应关系后，我们就来看一下一棵2-3树与红黑树之间的对比，如图所示。<br><div align="center"><br><img src="https://hexo-rxy.oss-cn-beijing.aliyuncs.com/data_structure/RBTree/2-3%E6%A0%91%E4%B8%8E%E7%BA%A2%E9%BB%91%E6%A0%91-%E6%95%B4%E4%BD%93%E5%AF%B9%E6%AF%94.png" width="100%" height="100%"><br></div>    <h3 id="4-红黑树的性质"><a href="#4-红黑树的性质" class="headerlink" title="4. 红黑树的性质"></a>4. 红黑树的性质</h3><p>讨论了2-3树与红黑树之间的关系，我们再回过头来看一下红黑树的5条定义和性质，会发现很好理解了。  </p><ol><li>每个节点或者是红色，或者是黑色<br>这条定义很好理解，在此不做解释。</li><li>根节点是黑色<br>根据之前说过的，红色的节点对应于2-3树中“3节点”中较小的那个节点，拆成两个“2节点”的话则是一个左子树的节点，即红色的节点总是可以和其父节点进行融合，所以红色节点一定有父节点，显然根节点不能是红色，所以根节点是黑色。</li><li>每一个叶子节点(最后的空节点)是黑色的<br>这条性质和第2条是对应的。对于叶子节点（最后的空节点），一颗空树的根节点也为黑色，所以与其说第三条是一条性质，不如说也是一个定义。</li><li>如果一个节点是红色的，那么它的孩子节点都是黑色的<br>根据上面2-3树与红黑树两种节点的对比图，我们很容易看到，红色节点的两个子树，对应2-3树中的话，要么是一个“2节点”，要么是一个“3节点”，而不管是“2节点”还是“3节点”，相连的第一个节点都是黑色的，所以说红色节点的孩子节点都是黑色的。</li><li>从任意一个节点到叶子节点，经过的黑色节点是一样的<br>根据2-3树与红黑树的关系对比图，可以发现，红黑树中一个黑色节点对应2-3树中一整个节点（“2节点”或“3节点”），而2-3树是完全平衡的树，从根节点到任意路径的叶子节点，经过的节点个数都是相同的，对应红黑树中，即从任意节点到叶子节点，经过的黑色节点是一样的。  </li></ol><h2 id="二、-红黑树添加元素"><a href="#二、-红黑树添加元素" class="headerlink" title="二、 红黑树添加元素"></a>二、 红黑树添加元素</h2><p>回忆刚刚提到的向2-3树中添加元素的过程，或者添加进一个“2节点”，形成一个“3节点”，或者添加进一个“3节点”，形成一个临时的“4节点”。理解了2-3树如何添加节点，对应红黑树就很好理解了。很容易知道，我们总是会将待插入的节点向父节点进行融合，所以我们将待插入的节点看成红色,即永远添加红色节点。<br>向一棵空树添加节点42。插入后，该节点是根节点，根据红黑树的性质，根节点必须是黑色，所以讲该节点染成黑色。  </p><div align="center"><br><img src="https://hexo-rxy.oss-cn-beijing.aliyuncs.com/data_structure/RBTree/%E7%BA%A2%E9%BB%91%E6%A0%91%E6%B7%BB%E5%8A%A0-%E6%A0%B9%E8%8A%82%E7%82%B9.png" width="50%" height="50%"><br></div><br>若向如图的红黑树中添加节点37。因为37比42小，所以添加在42的左子树，对应2-3树中，形成一个“3节点”。<br><div align="center"><br><img src="https://hexo-rxy.oss-cn-beijing.aliyuncs.com/data_structure/RBTree/%E7%BA%A2%E9%BB%91%E6%A0%91%E6%B7%BB%E5%8A%A0-%E5%B7%A6%E5%AD%90%E6%A0%91.png" width="80%" height="80%"><br></div><br>若向如图的红黑树中添加节点42。因为42比37大，所以添加在37的右子树。这样的话红色节点就出现在了一个节点的右子树中，所以此时需要进行左旋转，让树满足红黑树的性质。<br><div align="center"><br><img src="https://hexo-rxy.oss-cn-beijing.aliyuncs.com/data_structure/RBTree/%E7%BA%A2%E9%BB%91%E6%A0%91%E6%B7%BB%E5%8A%A0-%E5%B7%A6%E6%97%8B%E8%BD%AC.png" width="80%" height="80%"><br></div>   <h3 id="1-左旋转"><a href="#1-左旋转" class="headerlink" title="1. 左旋转"></a>1. 左旋转</h3><p>对于一般的情况，如何进行左旋转呢？我们要对下图的红黑树进行左旋转。</p><div align="center"><br><img src="https://hexo-rxy.oss-cn-beijing.aliyuncs.com/data_structure/RBTree/%E5%B7%A6%E6%97%8B%E8%BD%AC-%E5%88%9D%E5%A7%8B.png" width="40%" height="40%"><br></div><br>首先将node节点与x节点断开，其次将x的左子树作为node的右子树。<br><div align="center"><br><img src="https://hexo-rxy.oss-cn-beijing.aliyuncs.com/data_structure/RBTree/%E5%B7%A6%E6%97%8B%E8%BD%AC-%E8%BF%87%E7%A8%8B1.png " width="70%" height="70%"><br></div><br>然后再将node作为x新的左子树，之后要把x的颜色染成node的颜色，最后将node的颜色变为红色，这样就完成了左旋转的操作。<br><div align="center"><br><img src="https://hexo-rxy.oss-cn-beijing.aliyuncs.com/data_structure/RBTree/%E5%B7%A6%E6%97%8B%E8%BD%AC-%E8%BF%87%E7%A8%8B2.png" width="70%" height="70%"><br></div>  <h3 id="2-颜色翻转（flipColors）"><a href="#2-颜色翻转（flipColors）" class="headerlink" title="2. 颜色翻转（flipColors）"></a>2. 颜色翻转（flipColors）</h3><p>向红黑树中插入节点66，很容易知道插入到42右子树的位置，对应于2-3树的插入如图所示。 </p><div align="center"><br><img src="https://hexo-rxy.oss-cn-beijing.aliyuncs.com/data_structure/RBTree/%E9%A2%9C%E8%89%B2%E7%BF%BB%E8%BD%AC-1.png" width="70%" height="70%"><br></div><br>然而上面我们说到，我们总是要将新拆分出来的树的父亲节点向上进行融合，即这个父亲节点在红黑树中总是红色的，根据红黑树的性质，该父亲节点的两个孩子节点一定是黑色的。这样就需要将上一步形成的树进行颜色的翻转，变成如下图的形态。<br><div align="center"><br><img src="https://hexo-rxy.oss-cn-beijing.aliyuncs.com/data_structure/RBTree/%E9%A2%9C%E8%89%B2%E7%BF%BB%E8%BD%AC-2.png" width="50%" height="50%"><br></div>   <h3 id="3-右旋转"><a href="#3-右旋转" class="headerlink" title="3. 右旋转"></a>3. 右旋转</h3><p>向如图的红黑树中插入节点12，根据二分搜索树插入的操作，此时会形成一条链状的结构，对于2-3树中则是变形成为图中的样子，才能保证平衡性。所以在红黑树中，也要通过变形，变成与2-3树对应的形态。这种情况的变形操作，称为“右旋转”。  </p><div align="center"><br><img src="https://hexo-rxy.oss-cn-beijing.aliyuncs.com/data_structure/RBTree/%E5%8F%B3%E6%97%8B%E8%BD%AC-1.png" width="70%" height="70%"><br></div><br>一般的情况，右旋转操作同上面的左旋转操作很类似，下面我们一起来看一下过程。我们要对下图的红黑树进行右旋转的操作。<br><div align="center"><br><img src="https://hexo-rxy.oss-cn-beijing.aliyuncs.com/data_structure/RBTree/%E5%8F%B3%E6%97%8B%E8%BD%AC%E4%B8%80%E8%88%AC-%E5%88%9D%E5%A7%8B.png" width="50%" height="50%"><br></div><br>首先将node和x节点断开，将x的右子树T1作为node的左子树。<br><div align="center"><br><img src="https://hexo-rxy.oss-cn-beijing.aliyuncs.com/data_structure/RBTree/%E5%8F%B3%E6%97%8B%E8%BD%AC%E4%B8%80%E8%88%AC-%E8%BF%87%E7%A8%8B1.png" width="50%" height="50%"><br></div><br>其次将node作为x的右子树。<br><div align="center"><br><img src="https://hexo-rxy.oss-cn-beijing.aliyuncs.com/data_structure/RBTree/%E5%8F%B3%E6%97%8B%E8%BD%AC%E4%B8%80%E8%88%AC-%E8%BF%87%E7%A8%8B2.png" width="50%" height="50%"><br></div><br>接着要把x的颜色染成原来node的颜色，把node染成红色。<br><div align="center"><br><img src="https://hexo-rxy.oss-cn-beijing.aliyuncs.com/data_structure/RBTree/%E5%8F%B3%E6%97%8B%E8%BD%AC%E4%B8%80%E8%88%AC-%E8%BF%87%E7%A8%8B3.png" width="50%" height="50%"><br></div><br>然后很显然，需要再进行一次颜色翻转操作，才能满足红黑树的性质。<br><div align="center"><br><img src="https://hexo-rxy.oss-cn-beijing.aliyuncs.com/data_structure/RBTree/%E5%8F%B3%E6%97%8B%E8%BD%AC%E5%90%8E%E9%A2%9C%E8%89%B2%E7%BF%BB%E8%BD%AC.png" width="50%" height="50%"><br></div><br><br><br><br><br>有一种比较复杂的情况，向下图的红黑树中插入节点40,要满足的红黑树的性质我们需要怎么操作呢？<br><div align="center"><br><img src="https://hexo-rxy.oss-cn-beijing.aliyuncs.com/data_structure/RBTree/%E7%BA%A2%E9%BB%91%E6%A0%91%E6%8F%92%E5%85%A5%E5%A4%8D%E6%9D%82-1.png" width="70%" height="70%"><br></div><br>对应2-3树中最终的形态，第一步我们可以通过一次左旋转，变成下图的样子。<br><div align="center"><br><img src="https://hexo-rxy.oss-cn-beijing.aliyuncs.com/data_structure/RBTree/%E7%BA%A2%E9%BB%91%E6%A0%91%E6%8F%92%E5%85%A5%E5%A4%8D%E6%9D%82%E5%B7%A6%E6%97%8B%E8%BD%AC.png" width="60%" height="60%"><br></div><br>会发现，这样就变成了上面说到的需要右旋转的形态，所以再进行一次右旋转和颜色翻转，就可以满足红黑树的性质了。<br><div align="center"><br><img src="https://hexo-rxy.oss-cn-beijing.aliyuncs.com/data_structure/RBTree/%E7%BA%A2%E9%BB%91%E6%A0%91%E6%8F%92%E5%85%A5%E5%A4%8D%E6%9D%82%E5%8F%B3%E6%97%8B%E8%BD%AC%E9%A2%9C%E8%89%B2%E7%BF%BB%E8%BD%AC.png" width="90%" height="90%"><br></div>   <h3 id="4-红黑树插入总结"><a href="#4-红黑树插入总结" class="headerlink" title="4.红黑树插入总结"></a>4.红黑树插入总结</h3><p>上面分情况讨论了向红黑树中添加节点的各种情况，这里总结一下。其实根据上面的讨论，我们可以发现，最后一种复杂的情况可以涵盖其余简单的情况，复杂的操作包含了左旋转、右旋转、颜色翻转，这三种操作，完全可以保持红黑树的性质。下面的一张图，很好的总结了向红黑树中添加节点不同情况下的过程。  </p><div align="center"><br><img src="https://hexo-rxy.oss-cn-beijing.aliyuncs.com/data_structure/RBTree/%E7%BA%A2%E9%BB%91%E6%A0%91%E6%8F%92%E5%85%A5%E6%80%BB%E7%BB%93.png" width="90%" height="90%"><br></div>   <h2 id="三、红黑树删除元素"><a href="#三、红黑树删除元素" class="headerlink" title="三、红黑树删除元素"></a>三、红黑树删除元素</h2><p>关于红黑树的删除操作，比插入操作要复杂一些，需要分情况进行讨论。下面我们具体来看一下。<br>红黑树的删除操作大体分为2步：  </p><ol><li>二分搜索树删除节点  </li><li>删除修复操作  </li></ol><p>红黑树的删除首先满足二分搜索树的删除，然后对删除节点后的树进行修复操作，让其重新满足红黑树的5条性质。<br>对于二分搜索树的删除，这里就不再赘述，我们主要讨论红黑树的删除修复操作。以下所说的当前节点意思是通过二分搜索树的方式删除要删除的节点后，代替原来节点的节点。<br>当删除节点是红色节点时,那么原来红黑树的性质依旧保持，此时不用做修复操作。<br>当删除节点是黑色节点时,情况很多，我们分情况讨论。  </p><h3 id="1-简单情况"><a href="#1-简单情况" class="headerlink" title="1.简单情况"></a>1.简单情况</h3><ol><li>当前节点是红色节点<br>直接把当前节点染成黑色,结束，红黑树的性质全部恢复。  </li><li>当前节点是黑色节点，并且是根节点<br>什么都不做，直接结束。  </li></ol><h3 id="2-复杂情况"><a href="#2-复杂情况" class="headerlink" title="2.复杂情况"></a>2.复杂情况</h3><ol><li><p>N、S、SL、SR、P都为黑色<br>其中N是上述的当前节点，S是N的兄弟节点，P是N的父节点，SL和SR是N兄弟节点的左右孩子节点。</p><div align="center"><br><img src="https://hexo-rxy.oss-cn-beijing.aliyuncs.com/data_structure/RBTree/%E7%BA%A2%E9%BB%91%E6%A0%91%E5%88%A0%E9%99%A4%E6%83%85%E5%86%B51-1.png" width="40%" height="40%"><br></div><br>此时将S染成红色，这样经过N路径的黑色节点就和N的兄弟子树中的黑色节点相同了，但是经过P节点的黑色节点少了一个，此时需要将P当做新的N再进行操作，具体怎么操作可以见以下一些情况。<br><div align="center"><br><img src="https://hexo-rxy.oss-cn-beijing.aliyuncs.com/data_structure/RBTree/%E7%BA%A2%E9%BB%91%E6%A0%91%E5%88%A0%E9%99%A4%E6%83%85%E5%86%B51-2.png" width="40%" height="40%"><br></div>    </li><li><p>N、S、SL、SR为黑色，P为红色</p><div align="center"><br><img src="https://hexo-rxy.oss-cn-beijing.aliyuncs.com/data_structure/RBTree/%E7%BA%A2%E9%BB%91%E6%A0%91%E5%88%A0%E9%99%A4%E6%83%85%E5%86%B52-1.png" width="40%" height="40%"><br></div><br>此时将P和S的颜色进行交换,P成为了黑色,它为经过节点N的路径添加了一个黑色节点，从而补偿了被删除的黑色节点。S的颜色只是上移到父节点P上,因而经过S节点路径的黑色节点的数目也没有发生改变。<br><div align="center"><br><img src="https://hexo-rxy.oss-cn-beijing.aliyuncs.com/data_structure/RBTree/%E7%BA%A2%E9%BB%91%E6%A0%91%E5%88%A0%E9%99%A4%E6%83%85%E5%86%B52-2.png" width="40%" height="40%"><br></div>    </li><li><p>N、S为黑色，SR为红色<br>图中蓝色节点表示该节点可以为黑色也可以为红色，即对该节点的颜色没有要求。<br><div align="center"><br><img src="https://hexo-rxy.oss-cn-beijing.aliyuncs.com/data_structure/RBTree/%E7%BA%A2%E9%BB%91%E6%A0%91%E5%88%A0%E9%99%A4%E6%83%85%E5%86%B53-1.png" width="40%" height="40%"><br></div><br>此时将以P为根的子树进行左旋转<br><div align="center"><br><img src="https://hexo-rxy.oss-cn-beijing.aliyuncs.com/data_structure/RBTree/%E7%BA%A2%E9%BB%91%E6%A0%91%E5%88%A0%E9%99%A4%E6%83%85%E5%86%B53-2.png" width="40%" height="40%"><br></div><br>然后交换P和S的颜色<br><div align="center"><br><img src="https://hexo-rxy.oss-cn-beijing.aliyuncs.com/data_structure/RBTree/%E7%BA%A2%E9%BB%91%E6%A0%91%E5%88%A0%E9%99%A4%E6%83%85%E5%86%B53-3.png" width="40%" height="40%"><br></div><br>将SR染成黑色<br><div align="center"><br><img src="https://hexo-rxy.oss-cn-beijing.aliyuncs.com/data_structure/RBTree/%E7%BA%A2%E9%BB%91%E6%A0%91%E5%88%A0%E9%99%A4%E6%83%85%E5%86%B53-4.png" width="40%" height="40%"><br></div><br>调整后经由N的路径的黑色节点数比调整前增加了一个，恰好补偿了被删除的黑色节点。对于不经过N但经过其他节点的任意一个路径来说，它们贡献的黑色节点数目不变。  </p></li><li><p>N、S为黑色，SL为红色，SR为黑色<br><div align="center"><br><img src="https://hexo-rxy.oss-cn-beijing.aliyuncs.com/data_structure/RBTree/%E7%BA%A2%E9%BB%91%E6%A0%91%E5%88%A0%E9%99%A4%E6%83%85%E5%86%B54-1.png" width="40%" height="40%"><br></div><br>此时，将以S为根的子树进行右旋转<br><div align="center"><br><img src="https://hexo-rxy.oss-cn-beijing.aliyuncs.com/data_structure/RBTree/%E7%BA%A2%E9%BB%91%E6%A0%91%E5%88%A0%E9%99%A4%E6%83%85%E5%86%B54-2.png" width="40%" height="40%"><br></div><br>接着交换S和SL的颜色<br><div align="center"><br><img src="https://hexo-rxy.oss-cn-beijing.aliyuncs.com/data_structure/RBTree/%E7%BA%A2%E9%BB%91%E6%A0%91%E5%88%A0%E9%99%A4%E6%83%85%E5%86%B54-3.png" width="40%" height="40%"><br></div><br>节点SL的左孩子在旋转前后不变，而SL原来为红色，所以SL的左孩子必定为黑色。所以旋转后对于N节点来说，相当于情况3。之后再通过情况3中的描述进行操作。整体上情况4需要进行一次右旋转和一次左旋转。  </p></li><li><p>N为黑色，S为红色<br><div align="center"><br><img src="https://hexo-rxy.oss-cn-beijing.aliyuncs.com/data_structure/RBTree/%E7%BA%A2%E9%BB%91%E6%A0%91%E5%88%A0%E9%99%A4%E6%83%85%E5%86%B55-1.png" width="40%" height="40%"><br></div><br>此时，将以P为根的子树进行左旋转<br><div align="center"><br><img src="https://hexo-rxy.oss-cn-beijing.aliyuncs.com/data_structure/RBTree/%E7%BA%A2%E9%BB%91%E6%A0%91%E5%88%A0%E9%99%A4%E6%83%85%E5%86%B55-2.png" width="40%" height="40%"><br></div><br>将P和S颜色交换<br><div align="center"><br><img src="https://hexo-rxy.oss-cn-beijing.aliyuncs.com/data_structure/RBTree/%E7%BA%A2%E9%BB%91%E6%A0%91%E5%88%A0%E9%99%A4%E6%83%85%E5%86%B55-3.png" width="40%" height="40%"><br></div><br>经过这样的变换后，把该情形转化成了N为黑色，其兄弟为黑色的情形，再通过以上描述的几种情况进行变换，最终保持红黑树的性质。<br><br><br><br><br>红黑树删除的各种复杂的情况，以上都进行了讨论，虽然比较繁琐，但是认真研究后还是可以理解的，并没有之前想象地那么困难。  </p></li></ol><h2 id="四、红黑树的性能"><a href="#四、红黑树的性能" class="headerlink" title="四、红黑树的性能"></a>四、红黑树的性能</h2><p>红黑树的增删改查的复杂度显然是O(logn)级别的，通常说红黑树是统计性能更优的树结构。<br>为什么说统计性能更优呢？因为若是单纯的读操作，AVL树的性能比红黑树强一些，红黑树不是严格的平衡树，它是保持“黑平衡”的树。对于红黑树，最坏的情况，是树中最左侧的节点的左子树都是红色的节点，即对应2-3树中的“3节点”，所以这时红黑树的高度就是2logn（除了logn个黑色节点外，还有logn个红色节点），红黑树要比AVL树要高一些。所以从单纯的查询性能来说，红黑树的性能并没有AVL树强。<br>对于插入删除操作来说，红黑树相比于AVL树减少了左旋转或右旋转的次数，所以红黑树的插入删除的性能比AVL树强一些。<br>综合增删改查各方面的性能，红黑树的综合性能比较高。  </p><h2 id="五、红黑树的应用"><a href="#五、红黑树的应用" class="headerlink" title="五、红黑树的应用"></a>五、红黑树的应用</h2><ol><li>Java中的TreeMap，Java8中HashMap的TreeNode节点采用了红黑树实现  </li><li>C++中，STL的map和set也应用了红黑树</li><li>Linux中完全公平调度算法CFS(Completely Fair Schedule)</li><li>用红黑树管理进程控制块epoll在内核中的实现，用红黑树管理事件块</li><li>Nginx中，用红黑树管理timer等   </li></ol><hr><p>这次的分享，主要对红黑树的性质以及向红黑树中插入、删除元素进行分析，对于红黑树的应用并没有很深入的进行研究，如上所述的几种红黑树的应用，也只是了解，还需要在以后的工作学习中进行完善。以上是本人对红黑树学习的一些成果和心得，记下来让自己所学的知识体系化，也方便日后的复习回顾。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;前一段时间组内技术分享，正好趁这个机会好好研究了一下红黑树。在这里写下学习红黑树的一些成果和体会。&lt;/p&gt;
&lt;h2 id=&quot;一、什么是红黑树&quot;&gt;&lt;a href=&quot;#一、什么是红黑树&quot; class=&quot;headerlink&quot; title=&quot;一、什么是红黑树&quot;&gt;&lt;/a&gt;一、什么是
      
    
    </summary>
    
      <category term="数据结构" scheme="http://redmapleren.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="红黑树" scheme="http://redmapleren.com/tags/%E7%BA%A2%E9%BB%91%E6%A0%91/"/>
    
  </entry>
  
</feed>
